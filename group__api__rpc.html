<!-- HTML header for doxygen 1.9.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>C Microkernel Realtime eXecutive: Remote Procedure Calls</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="all">
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">C Microkernel Realtime eXecutive
   </div>
   <div id="projectbrief">Realtime Operating System for Cortex-M based microcontrollers</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__api__rpc.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a>  </div>
  <div class="headertitle"><div class="title">Remote Procedure Calls<div class="ingroups"><a class="el" href="group__api.html">Kernel API</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>API to perform calls that execute in foreign process.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gaac2c999e12c83857c3437c413cb7d47c" id="r_gaac2c999e12c83857c3437c413cb7d47c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__api__rpc.html#gaac2c999e12c83857c3437c413cb7d47c">IMPLEMENTATION</a>(service)&#160;&#160;&#160;CMRX_IMPLEMENTATION_HELPER(service, CMRX__INTERFACE__COUNTER)</td></tr>
<tr class="memdesc:gaac2c999e12c83857c3437c413cb7d47c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begin implementation of interface for service.  <br /></td></tr>
<tr class="separator:gaac2c999e12c83857c3437c413cb7d47c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3467c0dc3f1f95bb00289609f2ce35f8" id="r_ga3467c0dc3f1f95bb00289609f2ce35f8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__api__rpc.html#ga3467c0dc3f1f95bb00289609f2ce35f8">IMPLEMENTATION_OF</a>(service,  interface)</td></tr>
<tr class="memdesc:ga3467c0dc3f1f95bb00289609f2ce35f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extended version of IMPLEMENTATION macro.  <br /></td></tr>
<tr class="separator:ga3467c0dc3f1f95bb00289609f2ce35f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac79f9e6f9c7223d603a5ac7365617ea7" id="r_gac79f9e6f9c7223d603a5ac7365617ea7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__api__rpc.html#gac79f9e6f9c7223d603a5ac7365617ea7">INSTANCE</a>(a)&#160;&#160;&#160;void * a ## _</td></tr>
<tr class="memdesc:gac79f9e6f9c7223d603a5ac7365617ea7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark function argument as reference to current service instance.  <br /></td></tr>
<tr class="separator:gac79f9e6f9c7223d603a5ac7365617ea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50383951d2a9d4f1a855b2cec5e03274" id="r_ga50383951d2a9d4f1a855b2cec5e03274"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__api__rpc.html#ga50383951d2a9d4f1a855b2cec5e03274">this</a>&#160;&#160;&#160;CMRX_THIS_HELPER(CMRX__INTERFACE__COUNTER)</td></tr>
<tr class="memdesc:ga50383951d2a9d4f1a855b2cec5e03274"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access current service instance.  <br /></td></tr>
<tr class="separator:ga50383951d2a9d4f1a855b2cec5e03274"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>API to perform calls that execute in foreign process. </p>
<p>API to create remote procedure call services and to call them.</p>
<h1><a class="anchor" id="api_rpc_overview"></a>
RPC mechanism overview</h1>
<p>RPC mechanism is client-server-like mechanism based on interfaces. First, the interface must exist. This interface defines a range of operations that can be performed on some object. Next, any process within CMRX is free to provide an implementation of this interface. Then, it can define as many objects which support this implementation as it wants.</p>
<p>Any other process (even the same) - client can then call the implemented operations on the object as long as it knows the address of the object in the memory. For the client, the internal structure and content of the object are opaque and inaccessible. It can only call methods this object support in the implementation. The validity of call is checked at compile time. The validity of pointers is checked at runtime.</p>
<h1><a class="anchor" id="api_rpc_interface"></a>
RPC interfaces (vtables)</h1>
<p>RPC interfaces are defined in a form of type definition of structures containing pointers to functions. The sole purpose of interfaces is to declare a set of operations that are available for certain types of objects. Interfaces never provide any implementation, not even default one. Interfaces shall be as abstract as the topic of the interface possibly allows. The interface may consist of any amount of functions that have following limitations:</p><ul>
<li>first argument to the function call must be pointer to the object</li>
<li>other than the pointer to the object, functions can have 0 to 4 arguments that must be</li>
<li>integers. Interfaces never contain any data members, only pointer to functions. To make the code more readable, there is a helper macro to identify the pointer to object, named <a class="el" href="group__api__rpc.html#gac79f9e6f9c7223d603a5ac7365617ea7">INSTANCE()</a>. A type declaration, which consists exclusively of pointer-to-function members and these members follow the rules for RPC API are called vtables.</li>
</ul>
<h1><a class="anchor" id="api_rpc_implementation"></a>
Implementation of RPC interfaces</h1>
<p>Each process willing to provide RPC calls - the server - has to provide an implementation of these interfaces. The implementation of interface is performed by defining functions having prototypes equivalent to prototypes of vtable member functions. Unlike interfaces, where the pointer-to-object argument has no specific type (as the interface is abstract), with implementations it is necessary to type this pointer correctly. This is second responsibility of the <a class="el" href="group__api__rpc.html#gac79f9e6f9c7223d603a5ac7365617ea7">INSTANCE()</a> macro. During the implementation phase, it typecasts the <code>this</code> pointer to correct type, so strong type safety can be achieved.</p>
<p>Any amount of processes within one firmware can implement one specific interface. There is no limitation on this. One process can even provide multiple implementations of the same interface, for example in case that it manages multiple objects of different type, which all provide the same manipulation semantics.</p>
<p>In order to publish an implementation of some interface, a process must create a variable using desired interface's vtable structure. This variable will be initialized to contain pointers to functions that implement the interface. This variable <b>must</b> be defined within one of process' modules and <b>must</b> be prefixed by the <a class="el" href="group__api__init.html#gaa4a137442c139400b647ac62b40ea51a">VTABLE</a> keyword otherwise the kernel will refuse calls using such implementation for security reasons. This variable is known as vtable instance.</p>
<h1><a class="anchor" id="api_rpc_objects"></a>
RPC objects (services)</h1>
<p>After the interface has been implemented for certain process, it is possible to create structures which can be manipulated using the given interface. These services store the actual data for the implementation of the interface. Object structure is thus bound with the interface implementation. The only limitation given to services is that they have to contain a pointer to vtable instance, which is the first member of the structure holding service state. This will be checked at compile time and build will fail if service designer fails to stick to this rule.</p>
<h1><a class="anchor" id="api_rpc_instances"></a>
RPC service instances</h1>
<p>Where RPC service is a type which provides data storage to RPC interface implementation, the service instance is actual existing instance of this service. Service can't be used until instantiated. This instance can be allocated and initialized statically or dynamically. There are no limitations on where the instance resides other than limitations imposed by the memory protection mechanism. An instance of service translates to variable having the type of RPC service. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gaac2c999e12c83857c3437c413cb7d47c" name="gaac2c999e12c83857c3437c413cb7d47c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac2c999e12c83857c3437c413cb7d47c">&#9670;&#160;</a></span>IMPLEMENTATION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IMPLEMENTATION</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">service</td><td>)</td>
          <td>&#160;&#160;&#160;CMRX_IMPLEMENTATION_HELPER(service, CMRX__INTERFACE__COUNTER)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Begin implementation of interface for service. </p>
<p>Use of this macro starts implementation of methods for certain service. It enables use of the <code>this</code> term to refer to the service instance current during the method call. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">service</td><td>name of type which describes the service whose methods are being implemented </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3467c0dc3f1f95bb00289609f2ce35f8" name="ga3467c0dc3f1f95bb00289609f2ce35f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3467c0dc3f1f95bb00289609f2ce35f8">&#9670;&#160;</a></span>IMPLEMENTATION_OF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IMPLEMENTATION_OF</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">service, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">interface&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">CMRX_IMPLEMENTATION_HELPER(service, CMRX__INTERFACE__COUNTER);\</div>
<div class="line">_Static_assert(CMRX_CHECK_INTERFACE_MATCH(service, interface), CMRX_IMPLEMENTATION_TYPE_HELPER(service, interface))</div>
</div><!-- fragment -->
<p>Extended version of IMPLEMENTATION macro. </p>
<p>Use of this macro starts implementation of methods for certain service. It enables use of the <code>this</code> term to refer to the service instance current during the method call. Another function of this macro is that it generates a static assert to check, if the type of interface implemented by the service matches the one, which is expected here </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">service</td><td>type of structure, which holds instances of service </td></tr>
    <tr><td class="paramname">interface</td><td>type describing virtual method table of the implemented interface </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac79f9e6f9c7223d603a5ac7365617ea7" name="gac79f9e6f9c7223d603a5ac7365617ea7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac79f9e6f9c7223d603a5ac7365617ea7">&#9670;&#160;</a></span>INSTANCE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define INSTANCE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a</td><td>)</td>
          <td>&#160;&#160;&#160;void * a ## _</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark function argument as reference to current service instance. </p>
<p>Syntactic sugar to make argument type-compatible with interface declaration. This allows to work with any specific type of service inside its implementation and use of such specialized implementations to initialize generic interface. </p><dl class="section note"><dt>Note</dt><dd>As a matter of fact, the only allowed argument of this macro is <code>this</code></dd>
<dd>
Due to the API of RPC calls, you <em>HAVE</em> to use this macro on 1st argument of method definition. </dd></dl>

</div>
</div>
<a id="ga81ba1a4a057e20afe2dff72090f8193d" name="ga81ba1a4a057e20afe2dff72090f8193d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81ba1a4a057e20afe2dff72090f8193d">&#9670;&#160;</a></span>interface_cast</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define interface_cast</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">service&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;_Generic(((service)-&gt;vtable), typeof((*((type*) 0))-&gt;vtable) : (type) service, default: service)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform typecast of the service if and only if both services implement the same interface. </p>
<p>This macro performs conditional typecasting of service type to another service type. Type cast will only be performed if both services implement the same interface type (which means that both services contain vtable member and both these vtable members are of the same type). If service types don't match the typecast won't be made, most probably leading to a compilation warning that pointer types don't match. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>resulting service type </td></tr>
    <tr><td class="paramname">service</td><td>pointer to service </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga896b17abf6ce670f5000ac4a0852393f" name="ga896b17abf6ce670f5000ac4a0852393f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga896b17abf6ce670f5000ac4a0852393f">&#9670;&#160;</a></span>rpc_call</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define rpc_call</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">service_instance, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">method_name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;CMRX_RPC_CALL(service_instance, method_name __VA_OPT__(,) __VA_ARGS__)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User-visible way to perform remote procedure call. </p>
<p>Calls service published by different thread and/or process. Service can take 0 to 4 arguments, which are passed down to it. Return value of service is passed back to the caller. Services are represented by structures allocated in service provider thread. These structures have to contain pointer to their virtual method table as their first member. Virtual method table is then queried for presence of method name used to perform the call. If such method exists, then arguments used to perform the call are checked against method prototype. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">service_instance</td><td>address of service instance, which is being called </td></tr>
    <tr><td class="paramname">method_name</td><td>name of method within service, which has to be called </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whatever value service returned </dd></dl>

</div>
</div>
<a id="ga50383951d2a9d4f1a855b2cec5e03274" name="ga50383951d2a9d4f1a855b2cec5e03274"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50383951d2a9d4f1a855b2cec5e03274">&#9670;&#160;</a></span>this</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define this&#160;&#160;&#160;CMRX_THIS_HELPER(CMRX__INTERFACE__COUNTER)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access current service instance. </p>
<p><code>this</code> provides access to the current service instance. It is always typed correctly to access members of service currently being implemented. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga3be07e9a9f65c1035242a7c62863b58d" name="ga3be07e9a9f65c1035242a7c62863b58d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3be07e9a9f65c1035242a7c62863b58d">&#9670;&#160;</a></span>_rpc_call()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__os__syscall.html#ga6c52288e9645b2cd2c4ada0577669340">__SYSCALL</a> int _rpc_call </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>arg0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>arg2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>arg3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>service</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>canary</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal implementation of remote procedure call in userspace. </p>
<p>This function is actually called when user calles <a class="el" href="group__api__rpc.html#ga896b17abf6ce670f5000ac4a0852393f">rpc_call()</a>. The only difference is, that this signature takes method number instead it's name. Macro rpc_call will figure this out automatically.</p>
<dl class="section note"><dt>Note</dt><dd>Don't use this call directly, use <a class="el" href="group__api__rpc.html#ga896b17abf6ce670f5000ac4a0852393f">rpc_call</a> macro that performs some essential type checking before performing the call.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">service</td><td>address of service instance </td></tr>
    <tr><td class="paramname">method</td><td>offset of method in VMT of service </td></tr>
    <tr><td class="paramname">arg0</td><td>1st argument to the RPC call </td></tr>
    <tr><td class="paramname">arg1</td><td>2nd argument to the RPC call </td></tr>
    <tr><td class="paramname">arg2</td><td>3rd argument to the RPC call </td></tr>
    <tr><td class="paramname">arg3</td><td>4th argument to the RPC call </td></tr>
    <tr><td class="paramname">canary</td><td>canary value passed to the call </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whatever service method returns </dd></dl>

</div>
</div>
<a id="gaf78e5f7fb20b02cbff061e5ea6daaed3" name="gaf78e5f7fb20b02cbff061e5ea6daaed3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf78e5f7fb20b02cbff061e5ea6daaed3">&#9670;&#160;</a></span>rpc_return()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__os__syscall.html#ga6c52288e9645b2cd2c4ada0577669340">__SYSCALL</a> void rpc_return </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The way how RPC returns. </p>
<p>Used automatically.</p>
<p>Kernel uses this to return from RPC. It is hooked into RPC call chain automatically, no need to call it manually from RPC method. It is sufficient to return from RPC to call this. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.7-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</div>
</body>
</html>
