<!-- HTML header for doxygen 1.9.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>C Microkernel Realtime eXecutive: Transactional Processing</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="all">
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">C Microkernel Realtime eXecutive
   </div>
   <div id="projectbrief">Realtime Operating System for Cortex-M based microcontrollers</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('txn_intro.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Transactional Processing</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>One of important roles of any kernel is to keep things consistent at all times. This is rather trivial task even in a multi-threaded environment as long as your kernel processing does not get preempted. This normally does not happen, unless your ISRs are calling kernel services. Once they start doing so, the kernel code may get interrupted at any time with routines modifying the current kernel state.</p>
<p>Another similar, but not entirely the same situation happens if your kernel is running on multiple CPUs in SMP arrangement. Two CPU cores may execute kernel code in parallel.</p>
<p>While the latter situation can easily be resolved by using so called "big kernel locks" - locks which ever only allow one core to enter critical section - it won't help with interrupts.</p>
<p>If you allow interrupt to be handled while in critical section and this interrupt decides to enter this critical section, you get a deadlock situation. This is due to the priority inversion. Kernel code which is running inside ISR with lower priority holds a lock which prevents a code from higher priority ISR to proceed. Due to the priorities the code already holding the lock will never be able to proceed and everything hangs.</p>
<p>If you disable interrupts for the duration of the critical section, then the worst-case latency is hurt as you need to account for the longest-possible critical section blocking your interrupt from happening.</p>
<h2><a class="anchor" id="autotoc_md67"></a>
From critical section to transaction</h2>
<p>The approach selected for CMRX is to split critical section into two distinct parts. This split roughly aligns with transactional processing, thus this term was chosen to describe the behavior.</p>
<p>Critical sections also have three steps:</p><ol type="1">
<li>Lock the mutex and enter the critical section</li>
<li>Do whatever calculations needed in isolation and then modify the shared data structures</li>
<li>Unlock the mutex leaving critical sections allowing others to proceed</li>
</ol>
<p>Step 1 and 3 above are usually ignored as they are considered to happen immediately if no other code is already in the critical section.</p>
<p>You either get deadlocks in your interrupt service routines if you don't disable interrupts in critical sections, or your interrupt latency gets quite bad if you do.</p>
<p>To fight these two problems, different semantics is used. Code that would normally reside in critical section is said to reside inside transaction. Then the steps are:</p>
<ol type="1">
<li>Start the transaction obtaining transaction identifier</li>
<li>Do whatever calculations needed before you are ready to write into shared data structures</li>
<li>Commit transaction</li>
<li>If successful, then write changes do the shared data structures</li>
<li>Finish the transaction</li>
</ol>
<p>There are two additional steps. The main difference between critical section and transactional processing is that while step 2 of critical section happens inside the critical section, thus code has exclusive access to the shared resources, step 2 of transactional processing happens in normal mode of operation. This code can be interrupted or another code running on another <a class="el" href="group__os__sched.html#ga2057e79833f71e7a4793d51bc2dca106" title="CPU scheduling thread IDs.">core(s)</a> can modify the data while this code runs.</p>
<p>Normally that would lead to race conditions. With some caution in writing the code, this does not happen here. The step 3 of transactional processing makes the difference.</p>
<p>When the code makes an attempt to commit the transaction created in step 1, the transaction engine checks, if there was another transaction committed in between this transaction was created and the commit attempt has been made. It does not matter if this transaction happened inside ISR or on another core.</p>
<p>If another transaction has been <b>committed</b> while the computation of this transaction computation ran, then the computation is considered inconsistent. It is then up on the calling code to decide on what to do now. In some cases, transaction can be dismissed entirely. In other cases it has to be computed again.</p>
<p>If there was no conflict and commit is allowed, then critical section is entered and the code has exclusive access to the resources and can modify the shared kernel data. Here the <b>atomicity</b> is ensured.</p>
<h2><a class="anchor" id="autotoc_md69"></a>
Transaction caveats</h2>
<p>Unlike transactional databases, the transactional processing inside the kernel is not fully isolated. While computation of transactions happens outside of critical sections, it may happen that code running one core will read the data while critical section running on another core will update it.</p>
<p>This could be avoided by processing in isolation, creating a local copy of data being processed upon starting transaction. This would be extremely expensive as such kind of conflicts only happens rarely. In most cases, the effect of modification done inside the transaction only affects the local core. Thus the decision here is to make sure that changes made while committing transactions are made in a way that there won't be any transient hazard state generated.</p>
<p>Transient hazard state happens when the current state of data in shared kernel structures, if interpreted by another piece of code, could lead to an unexpected and unwanted behavior.</p>
<h2><a class="anchor" id="autotoc_md71"></a>
Transaction engine properties</h2>
<p>The transaction engine provides level of guarantees roughly at the level "read committed".</p>
<p>There are two types of transactions supported:</p><ul>
<li>read-only transactions - the sole purpose of these transactions is to make sure no other transaction has been committed while the computation was performed. This ensures that whatever data were read were in consistent state all the time.</li>
<li>read-write transactions - this type of transaction ensures that all writes to the shared context were made atomically and that no other read-only transaction will process these data in an inconsistent manner without knowing it.</li>
</ul>
<p>Guarantees offered:</p><ul>
<li>Atomicity of writes - changes written are written atomically, no two transactions will write their changes simultaneously. There is no guarantee that reads will be atomic. See isolation below. There can be only one transaction committing its changes at any time in the whole system.</li>
<li>Consistency awareness - computations made within transactions are let know if the shared state could become inconsistent. If this hint is honored and changes are written in a hazard-free way, then consistency of data is guaranteed even in read-only transactions. There can as many read-only transactions running in parallel as needed. Committing any of them won't abort any other concurrent read-only or read-write transaction. Yet if there is read-write transaction committed while there are read-only transaction opened, all of them will be aborted.</li>
</ul>
<p>Guarantees not offered:</p><ul>
<li>Isolation - read-only transactions don't access the data isolated from other (mostly read-write) transactions. There may happen a commit at any time of processing read-only transaction. Reads are not blocked while commit is writing modifications. Thus the code modifying the data must ensure there are no data hazards.</li>
<li>Durability - this guarantee is not provided as it makes no sense. The current state of the kernel is volatile. No persistence is provided. </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.7-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</div>
</body>
</html>
