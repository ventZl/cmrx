<!-- HTML header for doxygen 1.9.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>C Microkernel Realtime eXecutive: Thread scheduling</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="all">
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">C Microkernel Realtime eXecutive
   </div>
   <div id="projectbrief">Realtime Operating System for Cortex-M based microcontrollers</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__os__sched.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">Thread scheduling<div class="ingroups"><a class="el" href="group__os.html">Kernel documentation</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Kernel primitives for manipulating threads.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga88839b8a36578f9480c960dbc381448b" id="r_ga88839b8a36578f9480c960dbc381448b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__sched.html#ga88839b8a36578f9480c960dbc381448b">STACK_ALIGN</a></td></tr>
<tr class="separator:ga88839b8a36578f9480c960dbc381448b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c0157588be40efb99fc590662e237ae" id="r_ga1c0157588be40efb99fc590662e237ae"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__sched.html#ga1c0157588be40efb99fc590662e237ae">PRIORITY_INVALID</a>&#160;&#160;&#160;0x1FFU</td></tr>
<tr class="separator:ga1c0157588be40efb99fc590662e237ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa95d03c8fe4c7467a8e475748cbf67e1" id="r_gaa95d03c8fe4c7467a8e475748cbf67e1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__sched.html#gaa95d03c8fe4c7467a8e475748cbf67e1">PRIORITY_MAX</a>&#160;&#160;&#160;0xFFU</td></tr>
<tr class="separator:gaa95d03c8fe4c7467a8e475748cbf67e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1750d7e1f559518be7c25ed323065cf4" id="r_ga1750d7e1f559518be7c25ed323065cf4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__sched.html#ga1750d7e1f559518be7c25ed323065cf4">STACK_INVALID</a>&#160;&#160;&#160;0xFFFFFFFFU</td></tr>
<tr class="separator:ga1750d7e1f559518be7c25ed323065cf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26ea9f0ec722697387ee9deca8230844" id="r_ga26ea9f0ec722697387ee9deca8230844"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__sched.html#ga26ea9f0ec722697387ee9deca8230844">KERNEL_STRUCTS_INITIALIZED_SIGNATURE</a>&#160;&#160;&#160;0x434D5258</td></tr>
<tr class="separator:ga26ea9f0ec722697387ee9deca8230844"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaae12e635a9412afabedb95620d3e2ffe" id="r_gaae12e635a9412afabedb95620d3e2ffe"><td class="memItemLeft" align="right" valign="top">typedef uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__sched.html#gaae12e635a9412afabedb95620d3e2ffe">Thread_t</a></td></tr>
<tr class="separator:gaae12e635a9412afabedb95620d3e2ffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gae41148b47f9674a16741165066c4b066" id="r_gae41148b47f9674a16741165066c4b066"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__sched.html#gae41148b47f9674a16741165066c4b066">os_thread_alloc</a> (<a class="el" href="group__api.html#ga36958e2082eecb09f367fa4aa3a9a84d">Process_t</a> process, uint8_t priority)</td></tr>
<tr class="memdesc:gae41148b47f9674a16741165066c4b066"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate thread entry in thread table.  <br /></td></tr>
<tr class="separator:gae41148b47f9674a16741165066c4b066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33ba16e9e99099ad4a6831478774e195" id="r_ga33ba16e9e99099ad4a6831478774e195"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__sched.html#ga33ba16e9e99099ad4a6831478774e195">__os_thread_create</a> (<a class="el" href="group__api.html#ga36958e2082eecb09f367fa4aa3a9a84d">Process_t</a> process, entrypoint_t *entrypoint, void *data, uint8_t priority, uint8_t <a class="el" href="group__os__sched.html#ga2057e79833f71e7a4793d51bc2dca106">core</a>)</td></tr>
<tr class="memdesc:ga33ba16e9e99099ad4a6831478774e195"><td class="mdescLeft">&#160;</td><td class="mdescRight">Full workflow needed to create a thread.  <br /></td></tr>
<tr class="separator:ga33ba16e9e99099ad4a6831478774e195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga844762b99c00b298ab23f6d7f55e997b" id="r_ga844762b99c00b298ab23f6d7f55e997b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__sched.html#ga844762b99c00b298ab23f6d7f55e997b">os_get_next_thread</a> (uint8_t current_thread, uint8_t *next_thread)</td></tr>
<tr class="memdesc:ga844762b99c00b298ab23f6d7f55e997b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain next thread to run.  <br /></td></tr>
<tr class="separator:ga844762b99c00b298ab23f6d7f55e997b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b248188aaf965a21f9a4081290f5c24" id="r_ga9b248188aaf965a21f9a4081290f5c24"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__sched.html#ga9b248188aaf965a21f9a4081290f5c24">os_sched_yield</a> (void)</td></tr>
<tr class="memdesc:ga9b248188aaf965a21f9a4081290f5c24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kernel implementation of <a class="el" href="group__api__thread.html#ga98ad8277df91806691c7c51d1606861a" title="Give up processor.">sched_yield()</a> syscall.  <br /></td></tr>
<tr class="separator:ga9b248188aaf965a21f9a4081290f5c24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2eee99d75e6b65c227f65a6880f2e9f" id="r_gad2eee99d75e6b65c227f65a6880f2e9f"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__sched.html#gad2eee99d75e6b65c227f65a6880f2e9f">os_sched_timing_callback</a> (long <a class="el" href="group__os__timer.html#ga5a54481fa8804be03b96cbc5d85ec03b">delay_us</a>)</td></tr>
<tr class="memdesc:gad2eee99d75e6b65c227f65a6880f2e9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kernel callback for timing provider.  <br /></td></tr>
<tr class="separator:gad2eee99d75e6b65c227f65a6880f2e9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d76470d5f4abcaaf0ae4df66ecfc54c" id="r_ga0d76470d5f4abcaaf0ae4df66ecfc54c"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__sched.html#ga0d76470d5f4abcaaf0ae4df66ecfc54c">os_get_current_thread</a> (void)</td></tr>
<tr class="memdesc:ga0d76470d5f4abcaaf0ae4df66ecfc54c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kernel implementation of <a class="el" href="group__api__thread.html#ga52f86ad5da2364f17909fcb76bf84d71" title="Return current thread ID.">get_tid()</a> syscall.  <br /></td></tr>
<tr class="separator:ga0d76470d5f4abcaaf0ae4df66ecfc54c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a3c6cfe2ad6d5e166678dc2c7045150" id="r_ga9a3c6cfe2ad6d5e166678dc2c7045150"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__sched.html#ga9a3c6cfe2ad6d5e166678dc2c7045150">os_set_current_thread</a> (<a class="el" href="group__api.html#gaae12e635a9412afabedb95620d3e2ffe">Thread_t</a> new_thread)</td></tr>
<tr class="memdesc:ga9a3c6cfe2ad6d5e166678dc2c7045150"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kernel internal function to <em>override</em> current thread.  <br /></td></tr>
<tr class="separator:ga9a3c6cfe2ad6d5e166678dc2c7045150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3ee92a36f558b5a552c86c6dcce6c71" id="r_gae3ee92a36f558b5a552c86c6dcce6c71"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__sched.html#gae3ee92a36f558b5a552c86c6dcce6c71">os_get_current_stack</a> (void)</td></tr>
<tr class="memdesc:gae3ee92a36f558b5a552c86c6dcce6c71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get ID of stack used by current thread.  <br /></td></tr>
<tr class="separator:gae3ee92a36f558b5a552c86c6dcce6c71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b7c7fc2926c2c2e14942b4bcb0a432b" id="r_ga3b7c7fc2926c2c2e14942b4bcb0a432b"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__sched.html#ga3b7c7fc2926c2c2e14942b4bcb0a432b">os_get_current_process</a> (void)</td></tr>
<tr class="memdesc:ga3b7c7fc2926c2c2e14942b4bcb0a432b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kernel implementation of get_pid.  <br /></td></tr>
<tr class="separator:ga3b7c7fc2926c2c2e14942b4bcb0a432b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83f11a0a3d2e3efd962797d868000466" id="r_ga83f11a0a3d2e3efd962797d868000466"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__sched.html#ga83f11a0a3d2e3efd962797d868000466">os_get_micro_time</a> (void)</td></tr>
<tr class="memdesc:ga83f11a0a3d2e3efd962797d868000466"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get amount of microseconds elapsed since scheduler start.  <br /></td></tr>
<tr class="separator:ga83f11a0a3d2e3efd962797d868000466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ac48577d48e2adc3015536fe19eaa21" id="r_ga6ac48577d48e2adc3015536fe19eaa21"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__sched.html#ga6ac48577d48e2adc3015536fe19eaa21">os_idle_thread</a> (void *data)</td></tr>
<tr class="memdesc:ga6ac48577d48e2adc3015536fe19eaa21"><td class="mdescLeft">&#160;</td><td class="mdescRight">CMRX idle thread.  <br /></td></tr>
<tr class="separator:ga6ac48577d48e2adc3015536fe19eaa21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae770569b05079cac856ec58d207929d1" id="r_gae770569b05079cac856ec58d207929d1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__sched.html#gae770569b05079cac856ec58d207929d1">os_stack_create</a> ()</td></tr>
<tr class="memdesc:gae770569b05079cac856ec58d207929d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find free stack slot and allocate it.  <br /></td></tr>
<tr class="separator:gae770569b05079cac856ec58d207929d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee79d579e38cb5076959ad8d15aaba34" id="r_gaee79d579e38cb5076959ad8d15aaba34"><td class="memItemLeft" align="right" valign="top">uint32_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__sched.html#gaee79d579e38cb5076959ad8d15aaba34">os_stack_get</a> (int stack_id)</td></tr>
<tr class="memdesc:gaee79d579e38cb5076959ad8d15aaba34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get address of stack.  <br /></td></tr>
<tr class="separator:gaee79d579e38cb5076959ad8d15aaba34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad17dc6e8305ce5070b4d64f6ebc2ff6c" id="r_gad17dc6e8305ce5070b4d64f6ebc2ff6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__sched.html#gad17dc6e8305ce5070b4d64f6ebc2ff6c">os_stack_dispose</a> (uint32_t stack_id)</td></tr>
<tr class="memdesc:gad17dc6e8305ce5070b4d64f6ebc2ff6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release stack slot.  <br /></td></tr>
<tr class="separator:gad17dc6e8305ce5070b4d64f6ebc2ff6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf31f875c814fb6408ab42a5d7f502b6f" id="r_gaf31f875c814fb6408ab42a5d7f502b6f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__sched.html#gaf31f875c814fb6408ab42a5d7f502b6f">os_thread_exit</a> (int status)</td></tr>
<tr class="memdesc:gaf31f875c814fb6408ab42a5d7f502b6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kernel implementation of <a class="el" href="group__api__thread.html#ga189ee445e0ac8bf8fa112a2fa719d9b6" title="Terminate currently running thread.">thread_exit()</a> syscall.  <br /></td></tr>
<tr class="separator:gaf31f875c814fb6408ab42a5d7f502b6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga597750339c1651a9d631df439e2e981c" id="r_ga597750339c1651a9d631df439e2e981c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__sched.html#ga597750339c1651a9d631df439e2e981c">os_thread_kill</a> (uint8_t thread_id, int status)</td></tr>
<tr class="memdesc:ga597750339c1651a9d631df439e2e981c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kernel way to kill an arbitrary thread.  <br /></td></tr>
<tr class="separator:ga597750339c1651a9d631df439e2e981c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f6f80faa1ed7029bfb94e7f32f3a994" id="r_ga0f6f80faa1ed7029bfb94e7f32f3a994"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__sched.html#ga0f6f80faa1ed7029bfb94e7f32f3a994">os_thread_stop</a> (uint8_t thread_id)</td></tr>
<tr class="memdesc:ga0f6f80faa1ed7029bfb94e7f32f3a994"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kernel implementation of thread_stop() syscall.  <br /></td></tr>
<tr class="separator:ga0f6f80faa1ed7029bfb94e7f32f3a994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d13fca0696f3ab0fcf19b8d5503f31a" id="r_ga7d13fca0696f3ab0fcf19b8d5503f31a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__sched.html#ga7d13fca0696f3ab0fcf19b8d5503f31a">os_thread_continue</a> (uint8_t thread_id)</td></tr>
<tr class="memdesc:ga7d13fca0696f3ab0fcf19b8d5503f31a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kernel implementation of thread_continue() syscall.  <br /></td></tr>
<tr class="separator:ga7d13fca0696f3ab0fcf19b8d5503f31a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9548a96ef12f2d883d276855100191ef" id="r_ga9548a96ef12f2d883d276855100191ef"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__sched.html#ga9548a96ef12f2d883d276855100191ef">os_setpriority</a> (uint8_t priority)</td></tr>
<tr class="memdesc:ga9548a96ef12f2d883d276855100191ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kernel implementation of <a class="el" href="group__api__thread.html#gad14ed255ac7c3f9cfb0513c7d03e7cd8" title="Change thread priority.">setpriority()</a> syscall.  <br /></td></tr>
<tr class="separator:ga9548a96ef12f2d883d276855100191ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9b76e4b0629693553a999dd77dabc96" id="r_gac9b76e4b0629693553a999dd77dabc96"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__sched.html#gac9b76e4b0629693553a999dd77dabc96">cb_thread_join_notify</a> (const void *object, <a class="el" href="group__api.html#gaae12e635a9412afabedb95620d3e2ffe">Thread_t</a> thread, <a class="el" href="group__os__kernel.html#ga680eadb82b6578f258791cef85501af2">Event_t</a> event)</td></tr>
<tr class="separator:gac9b76e4b0629693553a999dd77dabc96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71b4f416aa58be6d354450e4f896e4d0" id="r_ga71b4f416aa58be6d354450e4f896e4d0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__sched.html#ga71b4f416aa58be6d354450e4f896e4d0">os_thread_join</a> (uint8_t thread_id)</td></tr>
<tr class="memdesc:ga71b4f416aa58be6d354450e4f896e4d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kernel implementation of <a class="el" href="group__api__thread.html#gafecb0503475d000bb26f547db0f54936" title="Wait for other thread to finish.">thread_join()</a> syscall.  <br /></td></tr>
<tr class="separator:ga71b4f416aa58be6d354450e4f896e4d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae211727af6e2835e21725cc95b0d65b0" id="r_gae211727af6e2835e21725cc95b0d65b0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__sched.html#gae211727af6e2835e21725cc95b0d65b0">os_thread_construct</a> (<a class="el" href="group__api.html#gaae12e635a9412afabedb95620d3e2ffe">Thread_t</a> tid, entrypoint_t *entrypoint, void *data, uint8_t core_id)</td></tr>
<tr class="memdesc:gae211727af6e2835e21725cc95b0d65b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make thread runnable.  <br /></td></tr>
<tr class="separator:gae211727af6e2835e21725cc95b0d65b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebb2e4fd35891b58767666454d4b78ea" id="r_gaebb2e4fd35891b58767666454d4b78ea"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__sched.html#gaebb2e4fd35891b58767666454d4b78ea">os_thread_create</a> (entrypoint_t *entrypoint, void *data, uint8_t priority)</td></tr>
<tr class="memdesc:gaebb2e4fd35891b58767666454d4b78ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Syscall handling <a class="el" href="group__api__thread.html#gab8850314cd6f6c4738a61cc3294dbbe0" title="Create new thread.">thread_create()</a> Creates new thread inside current process using specified entrypoint.  <br /></td></tr>
<tr class="separator:gaebb2e4fd35891b58767666454d4b78ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab30027c97dc034137c00192f28c6e178" id="r_gab30027c97dc034137c00192f28c6e178"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__sched.html#gab30027c97dc034137c00192f28c6e178">_os_start</a> (uint8_t start_core)</td></tr>
<tr class="memdesc:gab30027c97dc034137c00192f28c6e178"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start up scheduler.  <br /></td></tr>
<tr class="separator:gab30027c97dc034137c00192f28c6e178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3115342bb54e0e857c6a566334dcb76b" id="r_ga3115342bb54e0e857c6a566334dcb76b"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__sched.html#ga3115342bb54e0e857c6a566334dcb76b">os_shutdown</a> ()</td></tr>
<tr class="memdesc:ga3115342bb54e0e857c6a566334dcb76b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kernel implementation of the <a class="el" href="group__api__standard.html#gae1715e8318d2fce3df9a39f863d9493f" title="Shutdown CMRX kernel.">shutdown()</a> syscall.  <br /></td></tr>
<tr class="separator:ga3115342bb54e0e857c6a566334dcb76b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b7326827d532971c4612ab1751428e9" id="r_ga3b7326827d532971c4612ab1751428e9"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structOS__thread__t.html">OS_thread_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__sched.html#ga3b7326827d532971c4612ab1751428e9">os_thread_get</a> (<a class="el" href="group__api.html#gaae12e635a9412afabedb95620d3e2ffe">Thread_t</a> thread_id)</td></tr>
<tr class="memdesc:ga3b7326827d532971c4612ab1751428e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get thread descriptor.  <br /></td></tr>
<tr class="separator:ga3b7326827d532971c4612ab1751428e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1f37df2463307c3bbd30c193491d6aa" id="r_gaa1f37df2463307c3bbd30c193491d6aa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__sched.html#gaa1f37df2463307c3bbd30c193491d6aa">os_thread_migrate</a> (uint8_t thread_id, int target_core)</td></tr>
<tr class="memdesc:gaa1f37df2463307c3bbd30c193491d6aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Migrate thread between CPU cores.  <br /></td></tr>
<tr class="separator:gaa1f37df2463307c3bbd30c193491d6aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5725c397d24dc7de634648a43675bc74" id="r_ga5725c397d24dc7de634648a43675bc74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__sched.html#ga5725c397d24dc7de634648a43675bc74">os_thread_dispose</a> (void)</td></tr>
<tr class="memdesc:ga5725c397d24dc7de634648a43675bc74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias to thread_exit.  <br /></td></tr>
<tr class="separator:ga5725c397d24dc7de634648a43675bc74"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga5bcb4dcf2afcf71f716d8dc85b18134d" id="r_ga5bcb4dcf2afcf71f716d8dc85b18134d"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structOS__thread__t.html">OS_thread_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__sched.html#ga5bcb4dcf2afcf71f716d8dc85b18134d">os_threads</a> [<a class="el" href="group__os__config.html#ga1383e9a762dc5563440cf1623542667d">OS_THREADS</a>]</td></tr>
<tr class="memdesc:ga5bcb4dcf2afcf71f716d8dc85b18134d"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of active threads.  <br /></td></tr>
<tr class="separator:ga5bcb4dcf2afcf71f716d8dc85b18134d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92c7c87a5b690240597294d232980842" id="r_ga92c7c87a5b690240597294d232980842"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structOS__process__t.html">OS_process_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__sched.html#ga92c7c87a5b690240597294d232980842">os_processes</a> [<a class="el" href="group__os__config.html#gacac8dbdebb899857ee307d8c8d917392">OS_PROCESSES</a>]</td></tr>
<tr class="memdesc:ga92c7c87a5b690240597294d232980842"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of active processes.  <br /></td></tr>
<tr class="separator:ga92c7c87a5b690240597294d232980842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2057e79833f71e7a4793d51bc2dca106" id="r_ga2057e79833f71e7a4793d51bc2dca106"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structOS__core__state__t.html">OS_core_state_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__sched.html#ga2057e79833f71e7a4793d51bc2dca106">core</a> [<a class="el" href="group__os__config.html#ga1efb4303a8fe3497b166ba0e18be3477">OS_NUM_CORES</a>]</td></tr>
<tr class="memdesc:ga2057e79833f71e7a4793d51bc2dca106"><td class="mdescLeft">&#160;</td><td class="mdescRight">CPU scheduling thread IDs.  <br /></td></tr>
<tr class="separator:ga2057e79833f71e7a4793d51bc2dca106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea74e023a260529e36ff7609c8a53555" id="r_gaea74e023a260529e36ff7609c8a53555"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structOS__stack__t.html">OS_stack_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__sched.html#gaea74e023a260529e36ff7609c8a53555">os_stacks</a></td></tr>
<tr class="memdesc:gaea74e023a260529e36ff7609c8a53555"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread stacks.  <br /></td></tr>
<tr class="separator:gaea74e023a260529e36ff7609c8a53555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga575ede15b4fe0a42c29b7167d0822745" id="r_ga575ede15b4fe0a42c29b7167d0822745"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__sched.html#ga575ede15b4fe0a42c29b7167d0822745">sched_tick_increment</a></td></tr>
<tr class="memdesc:ga575ede15b4fe0a42c29b7167d0822745"><td class="mdescLeft">&#160;</td><td class="mdescRight">Amount of real time advance per one scheduler tick.  <br /></td></tr>
<tr class="separator:ga575ede15b4fe0a42c29b7167d0822745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6611cb1ff80f54abebb06a818d0a1ce2" id="r_ga6611cb1ff80f54abebb06a818d0a1ce2"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__sched.html#ga6611cb1ff80f54abebb06a818d0a1ce2">sched_microtime</a> = 0</td></tr>
<tr class="memdesc:ga6611cb1ff80f54abebb06a818d0a1ce2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current scheduler real time.  <br /></td></tr>
<tr class="separator:ga6611cb1ff80f54abebb06a818d0a1ce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2057e79833f71e7a4793d51bc2dca106" id="r_ga2057e79833f71e7a4793d51bc2dca106"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structOS__core__state__t.html">OS_core_state_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__sched.html#ga2057e79833f71e7a4793d51bc2dca106">core</a> [<a class="el" href="group__os__config.html#ga1efb4303a8fe3497b166ba0e18be3477">OS_NUM_CORES</a>]</td></tr>
<tr class="memdesc:ga2057e79833f71e7a4793d51bc2dca106"><td class="mdescLeft">&#160;</td><td class="mdescRight">CPU scheduling thread IDs.  <br /></td></tr>
<tr class="separator:ga2057e79833f71e7a4793d51bc2dca106"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Kernel primitives for manipulating threads. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga26ea9f0ec722697387ee9deca8230844" name="ga26ea9f0ec722697387ee9deca8230844"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga26ea9f0ec722697387ee9deca8230844">&#9670;&#160;</a></span>KERNEL_STRUCTS_INITIALIZED_SIGNATURE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define KERNEL_STRUCTS_INITIALIZED_SIGNATURE&#160;&#160;&#160;0x434D5258</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga1c0157588be40efb99fc590662e237ae" name="ga1c0157588be40efb99fc590662e237ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c0157588be40efb99fc590662e237ae">&#9670;&#160;</a></span>PRIORITY_INVALID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PRIORITY_INVALID&#160;&#160;&#160;0x1FFU</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaa95d03c8fe4c7467a8e475748cbf67e1" name="gaa95d03c8fe4c7467a8e475748cbf67e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa95d03c8fe4c7467a8e475748cbf67e1">&#9670;&#160;</a></span>PRIORITY_MAX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PRIORITY_MAX&#160;&#160;&#160;0xFFU</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga88839b8a36578f9480c960dbc381448b" name="ga88839b8a36578f9480c960dbc381448b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88839b8a36578f9480c960dbc381448b">&#9670;&#160;</a></span>STACK_ALIGN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define STACK_ALIGN</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga1750d7e1f559518be7c25ed323065cf4" name="ga1750d7e1f559518be7c25ed323065cf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1750d7e1f559518be7c25ed323065cf4">&#9670;&#160;</a></span>STACK_INVALID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define STACK_INVALID&#160;&#160;&#160;0xFFFFFFFFU</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gaae12e635a9412afabedb95620d3e2ffe" name="gaae12e635a9412afabedb95620d3e2ffe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae12e635a9412afabedb95620d3e2ffe">&#9670;&#160;</a></span>Thread_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint8_t <a class="el" href="group__api.html#gaae12e635a9412afabedb95620d3e2ffe">Thread_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga33ba16e9e99099ad4a6831478774e195" name="ga33ba16e9e99099ad4a6831478774e195"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga33ba16e9e99099ad4a6831478774e195">&#9670;&#160;</a></span>__os_thread_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int __os_thread_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__api.html#ga36958e2082eecb09f367fa4aa3a9a84d">Process_t</a>&#160;</td>
          <td class="paramname"><em>process</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">entrypoint_t *&#160;</td>
          <td class="paramname"><em>entrypoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>core</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Full workflow needed to create a thread. </p>
<p>This function is callable both from syscall and internally from kernel (during e.g. system startup) and performs complete thread creation workflow. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">process</td><td>ID of process owning the thread. Process must already be existing. </td></tr>
    <tr><td class="paramname">entrypoint</td><td>address of function which shall be executed as entrypoint into the thread </td></tr>
    <tr><td class="paramname">data</td><td>address of data block which should be passed to entrypoint function as an argument </td></tr>
    <tr><td class="paramname">priority</td><td>thread priority. Numerically lower values mean higher priorities </td></tr>
    <tr><td class="paramname">core</td><td>core on which thread will be created </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-negative values denote ID of thread just created, negative values mean errors. </dd></dl>

</div>
</div>
<a id="gab30027c97dc034137c00192f28c6e178" name="gab30027c97dc034137c00192f28c6e178"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab30027c97dc034137c00192f28c6e178">&#9670;&#160;</a></span>_os_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _os_start </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>start_core</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start up scheduler. </p>
<p>This function populates thread table based on thread autostart macro use. It also creates idle thread with priority 255 and starts scheduler. It never returns until you have very bad day. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start_core</td><td>number of core for which the kernel is started </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac9b76e4b0629693553a999dd77dabc96" name="gac9b76e4b0629693553a999dd77dabc96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac9b76e4b0629693553a999dd77dabc96">&#9670;&#160;</a></span>cb_thread_join_notify()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void cb_thread_join_notify </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__api.html#gaae12e635a9412afabedb95620d3e2ffe">Thread_t</a>&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__os__kernel.html#ga680eadb82b6578f258791cef85501af2">Event_t</a>&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga3b7c7fc2926c2c2e14942b4bcb0a432b" name="ga3b7c7fc2926c2c2e14942b4bcb0a432b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b7c7fc2926c2c2e14942b4bcb0a432b">&#9670;&#160;</a></span>os_get_current_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t os_get_current_process </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kernel implementation of get_pid. </p>
<dl class="section return"><dt>Returns</dt><dd>Current process ID. This is actually an offset in process table. </dd></dl>

</div>
</div>
<a id="gae3ee92a36f558b5a552c86c6dcce6c71" name="gae3ee92a36f558b5a552c86c6dcce6c71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3ee92a36f558b5a552c86c6dcce6c71">&#9670;&#160;</a></span>os_get_current_stack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t os_get_current_stack </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get ID of stack used by current thread. </p>
<dl class="section return"><dt>Returns</dt><dd>Current active stack ID. This is actually an offset in stack table. </dd></dl>

</div>
</div>
<a id="ga0d76470d5f4abcaaf0ae4df66ecfc54c" name="ga0d76470d5f4abcaaf0ae4df66ecfc54c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d76470d5f4abcaaf0ae4df66ecfc54c">&#9670;&#160;</a></span>os_get_current_thread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t os_get_current_thread </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kernel implementation of <a class="el" href="group__api__thread.html#ga52f86ad5da2364f17909fcb76bf84d71" title="Return current thread ID.">get_tid()</a> syscall. </p>
<dl class="section return"><dt>Returns</dt><dd>Current thread ID. This is actually an offset in thread table. </dd></dl>

</div>
</div>
<a id="ga83f11a0a3d2e3efd962797d868000466" name="ga83f11a0a3d2e3efd962797d868000466"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83f11a0a3d2e3efd962797d868000466">&#9670;&#160;</a></span>os_get_micro_time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t os_get_micro_time </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get amount of microseconds elapsed since scheduler start. </p>
<dl class="section return"><dt>Returns</dt><dd>internal kernel soft timer. This gets updated upon each systick handler call. It may jitter a bit. Wraps after about 4 million seconds. </dd></dl>

</div>
</div>
<a id="ga844762b99c00b298ab23f6d7f55e997b" name="ga844762b99c00b298ab23f6d7f55e997b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga844762b99c00b298ab23f6d7f55e997b">&#9670;&#160;</a></span>os_get_next_thread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool os_get_next_thread </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>current_thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>next_thread</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain next thread to run. </p>
<p>This function performs thread list lookup. It searches for thread, which is in ready state and has highest (numerically lowest) priority.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">current_thread</td><td>thread which is currently running </td></tr>
    <tr><td class="paramname">next_thread</td><td>pointer to variable where next thread ID will be stored </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if any runnable thread (different than current) was found, false otherwise. </dd></dl>

</div>
</div>
<a id="ga6ac48577d48e2adc3015536fe19eaa21" name="ga6ac48577d48e2adc3015536fe19eaa21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ac48577d48e2adc3015536fe19eaa21">&#9670;&#160;</a></span>os_idle_thread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int os_idle_thread </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CMRX idle thread. </p>
<p>This thread runs whenever no other CMRX thread is ready to be run. It does nothing useful. </p>

</div>
</div>
<a id="gad2eee99d75e6b65c227f65a6880f2e9f" name="gad2eee99d75e6b65c227f65a6880f2e9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad2eee99d75e6b65c227f65a6880f2e9f">&#9670;&#160;</a></span>os_sched_timing_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long os_sched_timing_callback </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>delay_us</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kernel callback for timing provider. </p>
<p>Kernel entrypoint for timed events. Kernel tells the timing provider, what is the delay before the next call, whenever this function is called. Timing provider shall then wait for given amount of time and then call this callback again. If the delay is 0, then timing provider can shutdown itself as there is no expected timed wakeup. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">delay_us</td><td>the actual amount of microseconds which happened since the last wakeup </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>amount of microseconds, which shall pass before next wakeup will happen. If this value is zero, then no next wakeup shall happen. </dd></dl>

</div>
</div>
<a id="ga9b248188aaf965a21f9a4081290f5c24" name="ga9b248188aaf965a21f9a4081290f5c24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9b248188aaf965a21f9a4081290f5c24">&#9670;&#160;</a></span>os_sched_yield()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int os_sched_yield </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kernel implementation of <a class="el" href="group__api__thread.html#ga98ad8277df91806691c7c51d1606861a" title="Give up processor.">sched_yield()</a> syscall. </p>
<p>Causes scheduler to consider another task to be ran. </p>

</div>
</div>
<a id="ga9a3c6cfe2ad6d5e166678dc2c7045150" name="ga9a3c6cfe2ad6d5e166678dc2c7045150"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a3c6cfe2ad6d5e166678dc2c7045150">&#9670;&#160;</a></span>os_set_current_thread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void os_set_current_thread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__api.html#gaae12e635a9412afabedb95620d3e2ffe">Thread_t</a>&#160;</td>
          <td class="paramname"><em>new_thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kernel internal function to <em>override</em> current thread. </p>
<p>DANGEROUS!!! </p>

</div>
</div>
<a id="ga9548a96ef12f2d883d276855100191ef" name="ga9548a96ef12f2d883d276855100191ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9548a96ef12f2d883d276855100191ef">&#9670;&#160;</a></span>os_setpriority()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int os_setpriority </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>priority</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kernel implementation of <a class="el" href="group__api__thread.html#gad14ed255ac7c3f9cfb0513c7d03e7cd8" title="Change thread priority.">setpriority()</a> syscall. </p>

</div>
</div>
<a id="ga3115342bb54e0e857c6a566334dcb76b" name="ga3115342bb54e0e857c6a566334dcb76b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3115342bb54e0e857c6a566334dcb76b">&#9670;&#160;</a></span>os_shutdown()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t os_shutdown </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kernel implementation of the <a class="el" href="group__api__standard.html#gae1715e8318d2fce3df9a39f863d9493f" title="Shutdown CMRX kernel.">shutdown()</a> syscall. </p>

</div>
</div>
<a id="gae770569b05079cac856ec58d207929d1" name="gae770569b05079cac856ec58d207929d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae770569b05079cac856ec58d207929d1">&#9670;&#160;</a></span>os_stack_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int os_stack_create </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find free stack slot and allocate it. </p>
<dl class="section return"><dt>Returns</dt><dd>If there is at least one free stack slot, then return it's ID. If no free stack is available, return STACK_INVALID constant. </dd></dl>

</div>
</div>
<a id="gad17dc6e8305ce5070b4d64f6ebc2ff6c" name="gad17dc6e8305ce5070b4d64f6ebc2ff6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad17dc6e8305ce5070b4d64f6ebc2ff6c">&#9670;&#160;</a></span>os_stack_dispose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void os_stack_dispose </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>stack_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release stack slot. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stack_id</td><td>Stack slot which should be released. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaee79d579e38cb5076959ad8d15aaba34" name="gaee79d579e38cb5076959ad8d15aaba34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee79d579e38cb5076959ad8d15aaba34">&#9670;&#160;</a></span>os_stack_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t * os_stack_get </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stack_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get address of stack. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stack_id</td><td>ID of stack </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>base address of stack </dd></dl>

</div>
</div>
<a id="gae41148b47f9674a16741165066c4b066" name="gae41148b47f9674a16741165066c4b066"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae41148b47f9674a16741165066c4b066">&#9670;&#160;</a></span>os_thread_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int os_thread_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__api.html#ga36958e2082eecb09f367fa4aa3a9a84d">Process_t</a>&#160;</td>
          <td class="paramname"><em>process</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate thread entry in thread table. </p>
<p>Will allocate entry in thread table. Thread won't be runnable after allocation, but thread ID will be reserved for it. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">process</td><td>ID of process owning the thread. Process must be existing already. </td></tr>
    <tr><td class="paramname">priority</td><td>tread priority </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Positive values denote thread ID reserved for new thread usable in further calls. Negative value means that there was no free slot in thread table to allocate new thread. </dd></dl>

</div>
</div>
<a id="gae211727af6e2835e21725cc95b0d65b0" name="gae211727af6e2835e21725cc95b0d65b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae211727af6e2835e21725cc95b0d65b0">&#9670;&#160;</a></span>os_thread_construct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int os_thread_construct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__api.html#gaae12e635a9412afabedb95620d3e2ffe">Thread_t</a>&#160;</td>
          <td class="paramname"><em>tid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">entrypoint_t *&#160;</td>
          <td class="paramname"><em>entrypoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>core_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make thread runnable. </p>
<p>This function will take previously allocated thread and will construct it's internal state, so that it is runnable. This includes stack allocation and filling in values, so that thread can be scheduled and run. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tid</td><td>Thread ID of thread to be constructed </td></tr>
    <tr><td class="paramname">entrypoint</td><td>pointer to thread entrypoint function </td></tr>
    <tr><td class="paramname">data</td><td>pointer to thread data. pass NULL pointer if no thread data is used </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>E_OK if thread was constructed, E_OUT_OF_STACKS if there is no free stack available and E_TASK_RUNNING if thread is not in state suitable for construction (either slot is free, or already constructed).</dd></dl>
<p>This function will take previously allocated thread and will construct it's internal state, so that it is runnable. This includes stack allocation and filling in values, so that thread can be scheduled and run. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tid</td><td>Thread ID of thread to be constructed </td></tr>
    <tr><td class="paramname">entrypoint</td><td>pointer to thread entrypoint function </td></tr>
    <tr><td class="paramname">data</td><td>pointer to thread data. pass NULL pointer if no thread data is used </td></tr>
    <tr><td class="paramname">core</td><td>ID of core the thread should run at </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>E_OK if thread was constructed, E_OUT_OF_STACKS if there is no free stack available and E_TASK_RUNNING if thread is not in state suitable for construction (either slot is free, or already constructed). </dd></dl>

</div>
</div>
<a id="ga7d13fca0696f3ab0fcf19b8d5503f31a" name="ga7d13fca0696f3ab0fcf19b8d5503f31a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d13fca0696f3ab0fcf19b8d5503f31a">&#9670;&#160;</a></span>os_thread_continue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int os_thread_continue </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kernel implementation of thread_continue() syscall. </p>

</div>
</div>
<a id="gaebb2e4fd35891b58767666454d4b78ea" name="gaebb2e4fd35891b58767666454d4b78ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaebb2e4fd35891b58767666454d4b78ea">&#9670;&#160;</a></span>os_thread_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int os_thread_create </td>
          <td>(</td>
          <td class="paramtype">entrypoint_t *&#160;</td>
          <td class="paramname"><em>entrypoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Syscall handling <a class="el" href="group__api__thread.html#gab8850314cd6f6c4738a61cc3294dbbe0" title="Create new thread.">thread_create()</a> Creates new thread inside current process using specified entrypoint. </p>
<p>Kernel implementation of <a class="el" href="group__api__thread.html#gab8850314cd6f6c4738a61cc3294dbbe0" title="Create new thread.">thread_create()</a> syscall. </p>

</div>
</div>
<a id="ga5725c397d24dc7de634648a43675bc74" name="ga5725c397d24dc7de634648a43675bc74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5725c397d24dc7de634648a43675bc74">&#9670;&#160;</a></span>os_thread_dispose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void os_thread_dispose </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias to thread_exit. </p>
<p>This is in fact the same function as <a class="el" href="group__api__thread.html#ga189ee445e0ac8bf8fa112a2fa719d9b6">thread_exit</a>. The only difference is that if for whatever reason syscall to <a class="el" href="group__os__sched.html#gaf31f875c814fb6408ab42a5d7f502b6f" title="Kernel implementation of thread_exit() syscall.">os_thread_exit()</a> will fail, this asserts. </p>

</div>
</div>
<a id="gaf31f875c814fb6408ab42a5d7f502b6f" name="gaf31f875c814fb6408ab42a5d7f502b6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf31f875c814fb6408ab42a5d7f502b6f">&#9670;&#160;</a></span>os_thread_exit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int os_thread_exit </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>status</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kernel implementation of <a class="el" href="group__api__thread.html#ga189ee445e0ac8bf8fa112a2fa719d9b6" title="Terminate currently running thread.">thread_exit()</a> syscall. </p>

</div>
</div>
<a id="ga3b7326827d532971c4612ab1751428e9" name="ga3b7326827d532971c4612ab1751428e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b7326827d532971c4612ab1751428e9">&#9670;&#160;</a></span>os_thread_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structOS__thread__t.html">OS_thread_t</a> * os_thread_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__api.html#gaae12e635a9412afabedb95620d3e2ffe">Thread_t</a>&#160;</td>
          <td class="paramname"><em>thread_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get thread descriptor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread_id</td><td>ID of thread </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>address of thread description strcture or NULL pointer if thread_id out of range. </dd></dl>

</div>
</div>
<a id="ga71b4f416aa58be6d354450e4f896e4d0" name="ga71b4f416aa58be6d354450e4f896e4d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga71b4f416aa58be6d354450e4f896e4d0">&#9670;&#160;</a></span>os_thread_join()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int os_thread_join </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>thread_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kernel implementation of <a class="el" href="group__api__thread.html#gafecb0503475d000bb26f547db0f54936" title="Wait for other thread to finish.">thread_join()</a> syscall. </p>

</div>
</div>
<a id="ga597750339c1651a9d631df439e2e981c" name="ga597750339c1651a9d631df439e2e981c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga597750339c1651a9d631df439e2e981c">&#9670;&#160;</a></span>os_thread_kill()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int os_thread_kill </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>thread_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kernel way to kill an arbitrary thread. </p>
<p>This call terminates any thread currently existing. There is no syscall for this right now. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread_id</td><td>ID of thread to be terminated. May even be thread currently running. </td></tr>
    <tr><td class="paramname">status</td><td>thread exit status </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if operation succeeded, error number otherwise </dd></dl>

</div>
</div>
<a id="gaa1f37df2463307c3bbd30c193491d6aa" name="gaa1f37df2463307c3bbd30c193491d6aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1f37df2463307c3bbd30c193491d6aa">&#9670;&#160;</a></span>os_thread_migrate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int os_thread_migrate </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>thread_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>target_core</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Migrate thread between CPU cores. </p>
<p>This function takes existing thread which is bound to some core and moved it over to scheduler queue of another core. In order for this call to be successful, the thread must already be stopped. If thread is woken up by e.g. signal arrived from interrupt service handler via <a class="el" href="group__api__isr.html#gabbc12f9850a82cd7f598e577efbee4bc" title="Send signal from ISR context.">isr_kill()</a> while this call is in progress then the call will fail. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread_id</td><td>ID of thread to be migrated </td></tr>
    <tr><td class="paramname">target_core</td><td>ID of core where the thread should be migrated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>E_OK if thread was migrated; E_INVALID if thread is not stopped or call is not made from the core at which the thread is currently running. </dd></dl>

</div>
</div>
<a id="ga0f6f80faa1ed7029bfb94e7f32f3a994" name="ga0f6f80faa1ed7029bfb94e7f32f3a994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f6f80faa1ed7029bfb94e7f32f3a994">&#9670;&#160;</a></span>os_thread_stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int os_thread_stop </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kernel implementation of thread_stop() syscall. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga2057e79833f71e7a4793d51bc2dca106" name="ga2057e79833f71e7a4793d51bc2dca106"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2057e79833f71e7a4793d51bc2dca106">&#9670;&#160;</a></span>core <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structOS__core__state__t.html">OS_core_state_t</a> core[<a class="el" href="group__os__config.html#ga1efb4303a8fe3497b166ba0e18be3477">OS_NUM_CORES</a>]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CPU scheduling thread IDs. </p>

</div>
</div>
<a id="ga2057e79833f71e7a4793d51bc2dca106" name="ga2057e79833f71e7a4793d51bc2dca106"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2057e79833f71e7a4793d51bc2dca106">&#9670;&#160;</a></span>core <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structOS__core__state__t.html">OS_core_state_t</a> core[<a class="el" href="group__os__config.html#ga1efb4303a8fe3497b166ba0e18be3477">OS_NUM_CORES</a>]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>CPU scheduling thread IDs. </p>

</div>
</div>
<a id="ga92c7c87a5b690240597294d232980842" name="ga92c7c87a5b690240597294d232980842"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92c7c87a5b690240597294d232980842">&#9670;&#160;</a></span>os_processes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structOS__process__t.html">OS_process_t</a> os_processes[<a class="el" href="group__os__config.html#gacac8dbdebb899857ee307d8c8d917392">OS_PROCESSES</a>]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>List of active processes. </p>
<p>Scheduler notion on existing processes. </p>

</div>
</div>
<a id="gaea74e023a260529e36ff7609c8a53555" name="gaea74e023a260529e36ff7609c8a53555"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea74e023a260529e36ff7609c8a53555">&#9670;&#160;</a></span>os_stacks</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structOS__stack__t.html">OS_stack_t</a> os_stacks</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Thread stacks. </p>
<p>Scheduler notion on existing stacks. </p>

</div>
</div>
<a id="ga5bcb4dcf2afcf71f716d8dc85b18134d" name="ga5bcb4dcf2afcf71f716d8dc85b18134d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5bcb4dcf2afcf71f716d8dc85b18134d">&#9670;&#160;</a></span>os_threads</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structOS__thread__t.html">OS_thread_t</a> os_threads[<a class="el" href="group__os__config.html#ga1383e9a762dc5563440cf1623542667d">OS_THREADS</a>]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>List of active threads. </p>
<p>Scheduler notion on existing threads. </p>

</div>
</div>
<a id="ga6611cb1ff80f54abebb06a818d0a1ce2" name="ga6611cb1ff80f54abebb06a818d0a1ce2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6611cb1ff80f54abebb06a818d0a1ce2">&#9670;&#160;</a></span>sched_microtime</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sched_microtime = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Current scheduler real time. </p>

</div>
</div>
<a id="ga575ede15b4fe0a42c29b7167d0822745" name="ga575ede15b4fe0a42c29b7167d0822745"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga575ede15b4fe0a42c29b7167d0822745">&#9670;&#160;</a></span>sched_tick_increment</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sched_tick_increment</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Amount of real time advance per one scheduler tick. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.7-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</div>
</body>
</html>
