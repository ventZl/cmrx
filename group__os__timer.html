<!-- HTML header for doxygen 1.9.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>C Microkernel Realtime eXecutive: Timers</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="all">
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">C Microkernel Realtime eXecutive
   </div>
   <div id="projectbrief">Realtime Operating System for Cortex-M based microcontrollers</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__os__timer.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">Timers<div class="ingroups"><a class="el" href="group__os.html">Kernel documentation</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Kernel internals providing services of delayed and periodic execution.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTimerEntry__t.html">TimerEntry_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Description of one sleep request.  <a href="structTimerEntry__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gafd9f6f3e031b55953acdb227a28431c6" id="r_gafd9f6f3e031b55953acdb227a28431c6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__timer.html#gafd9f6f3e031b55953acdb227a28431c6">eSleepType</a> { <a class="el" href="group__os__timer.html#ggafd9f6f3e031b55953acdb227a28431c6a838720ad69f2a9be2796ad3749a36a7f">TIMER_SLEEP</a> = 0
, <a class="el" href="group__os__timer.html#ggafd9f6f3e031b55953acdb227a28431c6ac6e6a01a6b4fad4c8054e0065442bdf7">TIMER_TIMEOUT</a>
, <a class="el" href="group__os__timer.html#ggafd9f6f3e031b55953acdb227a28431c6a21b44bcff4202d25ac1a56331ab4f841">TIMER_PERIODIC</a>
, <a class="el" href="group__os__timer.html#ggafd9f6f3e031b55953acdb227a28431c6a9d15e28429ade0cef1a25ce75af95197">TIMER_INTERVAL</a> = TIMER_PERIODIC
 }</td></tr>
<tr class="separator:gafd9f6f3e031b55953acdb227a28431c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gabc0c9f6d25c5678e6c4c9d88d1edb9bd" id="r_gabc0c9f6d25c5678e6c4c9d88d1edb9bd"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__timer.html#gabc0c9f6d25c5678e6c4c9d88d1edb9bd">is_periodic</a> (struct <a class="el" href="structTimerEntry__t.html">TimerEntry_t</a> *entry)</td></tr>
<tr class="memdesc:gabc0c9f6d25c5678e6c4c9d88d1edb9bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if interval in sleep entry is periodic or not.  <br /></td></tr>
<tr class="separator:gabc0c9f6d25c5678e6c4c9d88d1edb9bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacee9648cc90be455d550756ca473a56f" id="r_gacee9648cc90be455d550756ca473a56f"><td class="memItemLeft" align="right" valign="top">static unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__timer.html#gacee9648cc90be455d550756ca473a56f">get_sleeptime</a> (const unsigned interval)</td></tr>
<tr class="memdesc:gacee9648cc90be455d550756ca473a56f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get how long the sleep should take.  <br /></td></tr>
<tr class="separator:gacee9648cc90be455d550756ca473a56f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef90c3e49cedd75a22cf512bad8c149f" id="r_gaef90c3e49cedd75a22cf512bad8c149f"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__timer.html#gaef90c3e49cedd75a22cf512bad8c149f">do_set_timed_event</a> (<a class="el" href="group__os__txn.html#gac01e3878510de719773a39e4333a84f4">Txn_t</a> txn, unsigned slot, unsigned interval, enum <a class="el" href="group__os__timer.html#gafd9f6f3e031b55953acdb227a28431c6">eSleepType</a> type)</td></tr>
<tr class="memdesc:gaef90c3e49cedd75a22cf512bad8c149f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform heavy lifting of setting timers This routine will store timed event into list of timed events.  <br /></td></tr>
<tr class="separator:gaef90c3e49cedd75a22cf512bad8c149f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec8710b5e044f94721e76f945f9f35db" id="r_gaec8710b5e044f94721e76f945f9f35db"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__timer.html#gaec8710b5e044f94721e76f945f9f35db">set_timed_event</a> (unsigned microseconds, enum <a class="el" href="group__os__timer.html#gafd9f6f3e031b55953acdb227a28431c6">eSleepType</a> type)</td></tr>
<tr class="memdesc:gaec8710b5e044f94721e76f945f9f35db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a slot for timed event and store it.  <br /></td></tr>
<tr class="separator:gaec8710b5e044f94721e76f945f9f35db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71b8644d6ba7eec3e03baf9c86960143" id="r_ga71b8644d6ba7eec3e03baf9c86960143"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__timer.html#ga71b8644d6ba7eec3e03baf9c86960143">cancel_timed_event</a> (<a class="el" href="group__api.html#gaae12e635a9412afabedb95620d3e2ffe">Thread_t</a> owner, enum <a class="el" href="group__os__timer.html#gafd9f6f3e031b55953acdb227a28431c6">eSleepType</a> type)</td></tr>
<tr class="memdesc:ga71b8644d6ba7eec3e03baf9c86960143"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancels existing timed event.  <br /></td></tr>
<tr class="separator:ga71b8644d6ba7eec3e03baf9c86960143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a54481fa8804be03b96cbc5d85ec03b" id="r_ga5a54481fa8804be03b96cbc5d85ec03b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__timer.html#ga5a54481fa8804be03b96cbc5d85ec03b">delay_us</a> (uint32_t period_us)</td></tr>
<tr class="memdesc:ga5a54481fa8804be03b96cbc5d85ec03b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform short busy wait.  <br /></td></tr>
<tr class="separator:ga5a54481fa8804be03b96cbc5d85ec03b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga579228f0ea6911563f3c09d50b0f441d" id="r_ga579228f0ea6911563f3c09d50b0f441d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__timer.html#ga579228f0ea6911563f3c09d50b0f441d">os_usleep</a> (unsigned microseconds)</td></tr>
<tr class="memdesc:ga579228f0ea6911563f3c09d50b0f441d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kernel implementation of <a class="el" href="group__api__timer.html#ga6987ccb3233088dddefcf26bb39f249a" title="Suspend thread execution for short time.">usleep()</a> syscall.  <br /></td></tr>
<tr class="separator:ga579228f0ea6911563f3c09d50b0f441d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad144032be21d6335801e51f3668d62d7" id="r_gad144032be21d6335801e51f3668d62d7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__timer.html#gad144032be21d6335801e51f3668d62d7">os_setitimer</a> (unsigned microseconds)</td></tr>
<tr class="memdesc:gad144032be21d6335801e51f3668d62d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kernel implementation of <a class="el" href="group__api__timer.html#ga9f408bf7753a44225214c63f3285e440" title="Set interval timer to be called periodically.">setitimer()</a> syscall.  <br /></td></tr>
<tr class="separator:gad144032be21d6335801e51f3668d62d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b581bf8c03d871934b4d2fd1845a343" id="r_ga7b581bf8c03d871934b4d2fd1845a343"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__timer.html#ga7b581bf8c03d871934b4d2fd1845a343">os_timer_init</a> ()</td></tr>
<tr class="memdesc:ga7b581bf8c03d871934b4d2fd1845a343"><td class="mdescLeft">&#160;</td><td class="mdescRight">This routine initializes kernel scheduling subsystem.  <br /></td></tr>
<tr class="separator:ga7b581bf8c03d871934b4d2fd1845a343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga298a4922fb4180235c76c8cc8fecb6f5" id="r_ga298a4922fb4180235c76c8cc8fecb6f5"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__timer.html#ga298a4922fb4180235c76c8cc8fecb6f5">get_sleep_time</a> (uint32_t sleep_from, uint32_t microtime)</td></tr>
<tr class="memdesc:ga298a4922fb4180235c76c8cc8fecb6f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to calculate time considering type wraparound.  <br /></td></tr>
<tr class="separator:ga298a4922fb4180235c76c8cc8fecb6f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6a7c0053f7960e97d395651f4d08fad" id="r_gac6a7c0053f7960e97d395651f4d08fad"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__timer.html#gac6a7c0053f7960e97d395651f4d08fad">os_schedule_timer</a> (unsigned *delay)</td></tr>
<tr class="memdesc:gac6a7c0053f7960e97d395651f4d08fad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide information on next scheduled event.  <br /></td></tr>
<tr class="separator:gac6a7c0053f7960e97d395651f4d08fad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga807091ac93d2fe8f891d40f39b49b7da" id="r_ga807091ac93d2fe8f891d40f39b49b7da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__timer.html#ga807091ac93d2fe8f891d40f39b49b7da">os_run_timer</a> (uint32_t microtime)</td></tr>
<tr class="memdesc:ga807091ac93d2fe8f891d40f39b49b7da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fire scheduled event.  <br /></td></tr>
<tr class="separator:ga807091ac93d2fe8f891d40f39b49b7da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7790e1b47e7589223de470f32523408d" id="r_ga7790e1b47e7589223de470f32523408d"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__timer.html#ga7790e1b47e7589223de470f32523408d">os_cpu_freq_get</a> (void)</td></tr>
<tr class="memdesc:ga7790e1b47e7589223de470f32523408d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current CPU frequency.  <br /></td></tr>
<tr class="separator:ga7790e1b47e7589223de470f32523408d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gaa0e811d6349480297cbad82c700077de" id="r_gaa0e811d6349480297cbad82c700077de"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structTimerEntry__t.html">TimerEntry_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__timer.html#gaa0e811d6349480297cbad82c700077de">sleepers</a> [<a class="el" href="group__os__config.html#gac1843ed039050da6d9253cfba6ed8caa">SLEEPERS_MAX</a>]</td></tr>
<tr class="memdesc:gaa0e811d6349480297cbad82c700077de"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of all delays requested from kernel.  <br /></td></tr>
<tr class="separator:gaa0e811d6349480297cbad82c700077de"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Kernel internals providing services of delayed and periodic execution. </p>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gafd9f6f3e031b55953acdb227a28431c6" name="gafd9f6f3e031b55953acdb227a28431c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd9f6f3e031b55953acdb227a28431c6">&#9670;&#160;</a></span>eSleepType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__os__timer.html#gafd9f6f3e031b55953acdb227a28431c6">eSleepType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggafd9f6f3e031b55953acdb227a28431c6a838720ad69f2a9be2796ad3749a36a7f" name="ggafd9f6f3e031b55953acdb227a28431c6a838720ad69f2a9be2796ad3749a36a7f"></a>TIMER_SLEEP&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ggafd9f6f3e031b55953acdb227a28431c6ac6e6a01a6b4fad4c8054e0065442bdf7" name="ggafd9f6f3e031b55953acdb227a28431c6ac6e6a01a6b4fad4c8054e0065442bdf7"></a>TIMER_TIMEOUT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ggafd9f6f3e031b55953acdb227a28431c6a21b44bcff4202d25ac1a56331ab4f841" name="ggafd9f6f3e031b55953acdb227a28431c6a21b44bcff4202d25ac1a56331ab4f841"></a>TIMER_PERIODIC&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ggafd9f6f3e031b55953acdb227a28431c6a9d15e28429ade0cef1a25ce75af95197" name="ggafd9f6f3e031b55953acdb227a28431c6a9d15e28429ade0cef1a25ce75af95197"></a>TIMER_INTERVAL&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga71b8644d6ba7eec3e03baf9c86960143" name="ga71b8644d6ba7eec3e03baf9c86960143"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga71b8644d6ba7eec3e03baf9c86960143">&#9670;&#160;</a></span>cancel_timed_event()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int cancel_timed_event </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__api.html#gaae12e635a9412afabedb95620d3e2ffe">Thread_t</a>&#160;</td>
          <td class="paramname"><em>owner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__os__timer.html#gafd9f6f3e031b55953acdb227a28431c6">eSleepType</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cancels existing timed event. </p>
<p>This function is only accessible for periodic timers externally. It allows cancelling of interval timers set previously. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">owner</td><td>thread which shall own the interval timer </td></tr>
    <tr><td class="paramname">type</td><td>type of the event to be cancelled </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if operation performed succesfully. </dd></dl>

</div>
</div>
<a id="ga5a54481fa8804be03b96cbc5d85ec03b" name="ga5a54481fa8804be03b96cbc5d85ec03b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a54481fa8804be03b96cbc5d85ec03b">&#9670;&#160;</a></span>delay_us()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void delay_us </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>period_us</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform short busy wait. </p>
<p>This will perform busywait in the context of current thread. Useful to do short waits for I/O. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">period_us</td><td>how long the wait should take </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaef90c3e49cedd75a22cf512bad8c149f" name="gaef90c3e49cedd75a22cf512bad8c149f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef90c3e49cedd75a22cf512bad8c149f">&#9670;&#160;</a></span>do_set_timed_event()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int do_set_timed_event </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__os__txn.html#gac01e3878510de719773a39e4333a84f4">Txn_t</a>&#160;</td>
          <td class="paramname"><em>txn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__os__timer.html#gafd9f6f3e031b55953acdb227a28431c6">eSleepType</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform heavy lifting of setting timers This routine will store timed event into list of timed events. </p>
<p>If event is not periodic, it will also stop thread (<a class="el" href="group__os__timer.html#ga579228f0ea6911563f3c09d50b0f441d">os_usleep</a> semantics).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">txn</td><td>transaction used to modify the table </td></tr>
    <tr><td class="paramname">slot</td><td>number of slot in <a class="el" href="group__os__timer.html#gaa0e811d6349480297cbad82c700077de">sleepers</a> list </td></tr>
    <tr><td class="paramname">interval</td><td>amount of us for which thread should sleep </td></tr>
    <tr><td class="paramname">type</td><td>type of timer to set up </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if timer was set up properly </dd></dl>

</div>
</div>
<a id="ga298a4922fb4180235c76c8cc8fecb6f5" name="ga298a4922fb4180235c76c8cc8fecb6f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga298a4922fb4180235c76c8cc8fecb6f5">&#9670;&#160;</a></span>get_sleep_time()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t get_sleep_time </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>sleep_from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>microtime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to calculate time considering type wraparound. </p>
<p>This function will calculate the final time considering timer wraparound. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sleep_from</td><td>time at which the sleep starts (microseconds) </td></tr>
    <tr><td class="paramname">microtime</td><td>duration of sleep (microseconds) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new value of kernel timer at the end of sleep </dd></dl>

</div>
</div>
<a id="gacee9648cc90be455d550756ca473a56f" name="gacee9648cc90be455d550756ca473a56f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacee9648cc90be455d550756ca473a56f">&#9670;&#160;</a></span>get_sleeptime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned get_sleeptime </td>
          <td>(</td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>interval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get how long the sleep should take. </p>
<p>Will clean the periodicity flag from interval. </p><dl class="section return"><dt>Returns</dt><dd>sleep time in microseconds. </dd></dl>

</div>
</div>
<a id="gabc0c9f6d25c5678e6c4c9d88d1edb9bd" name="gabc0c9f6d25c5678e6c4c9d88d1edb9bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc0c9f6d25c5678e6c4c9d88d1edb9bd">&#9670;&#160;</a></span>is_periodic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool is_periodic </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structTimerEntry__t.html">TimerEntry_t</a> *&#160;</td>
          <td class="paramname"><em>entry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if interval in sleep entry is periodic or not. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if interval is periodic, 0 if interval is one-shot. </dd></dl>

</div>
</div>
<a id="ga7790e1b47e7589223de470f32523408d" name="ga7790e1b47e7589223de470f32523408d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7790e1b47e7589223de470f32523408d">&#9670;&#160;</a></span>os_cpu_freq_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t os_cpu_freq_get </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get current CPU frequency. </p>
<p>Will return the current CPU frequency (if known and/or available). </p><dl class="section return"><dt>Returns</dt><dd>CPU frequency in Hz, 0 if value is not known. </dd></dl>

</div>
</div>
<a id="ga807091ac93d2fe8f891d40f39b49b7da" name="ga807091ac93d2fe8f891d40f39b49b7da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga807091ac93d2fe8f891d40f39b49b7da">&#9670;&#160;</a></span>os_run_timer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void os_run_timer </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>microtime</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fire scheduled event. </p>
<p>Will find and run scheduled event. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">microtime</td><td>current processor time in microseconds </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac6a7c0053f7960e97d395651f4d08fad" name="gac6a7c0053f7960e97d395651f4d08fad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6a7c0053f7960e97d395651f4d08fad">&#9670;&#160;</a></span>os_schedule_timer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool os_schedule_timer </td>
          <td>(</td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>delay</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provide information on next scheduled event. </p>
<p>This function informs caller about delay until next scheduled event. Next scheduled event may be either wake-up of sleeped thread, or interval timer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">delay</td><td>address of buffer, where delay to next scheduled event will be written </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if there is any scheduled event known and at address pointed to by delay value was written. Returns false if there is no known scheduled event. In such case content of memory pointed to by delay is undefined. </dd></dl>

</div>
</div>
<a id="gad144032be21d6335801e51f3668d62d7" name="gad144032be21d6335801e51f3668d62d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad144032be21d6335801e51f3668d62d7">&#9670;&#160;</a></span>os_setitimer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int os_setitimer </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>microseconds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kernel implementation of <a class="el" href="group__api__timer.html#ga9f408bf7753a44225214c63f3285e440" title="Set interval timer to be called periodically.">setitimer()</a> syscall. </p>
<p>See <a class="el" href="group__api__timer.html#ga9f408bf7753a44225214c63f3285e440">setitimer</a> for details on arguments. </p>

</div>
</div>
<a id="ga7b581bf8c03d871934b4d2fd1845a343" name="ga7b581bf8c03d871934b4d2fd1845a343"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b581bf8c03d871934b4d2fd1845a343">&#9670;&#160;</a></span>os_timer_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void os_timer_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This routine initializes kernel scheduling subsystem. </p>
<p>It is necessary to call this routine before first call to either timer syscalls, or <a class="el" href="group__os__timer.html#ga807091ac93d2fe8f891d40f39b49b7da">os_run_timer</a> otherwise things will go wrong. </p>

</div>
</div>
<a id="ga579228f0ea6911563f3c09d50b0f441d" name="ga579228f0ea6911563f3c09d50b0f441d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga579228f0ea6911563f3c09d50b0f441d">&#9670;&#160;</a></span>os_usleep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int os_usleep </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>microseconds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kernel implementation of <a class="el" href="group__api__timer.html#ga6987ccb3233088dddefcf26bb39f249a" title="Suspend thread execution for short time.">usleep()</a> syscall. </p>
<p>See <a class="el" href="group__api__timer.html#ga6987ccb3233088dddefcf26bb39f249a">usleep</a> for details on arguments. </p>

</div>
</div>
<a id="gaec8710b5e044f94721e76f945f9f35db" name="gaec8710b5e044f94721e76f945f9f35db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec8710b5e044f94721e76f945f9f35db">&#9670;&#160;</a></span>set_timed_event()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int set_timed_event </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>microseconds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__os__timer.html#gafd9f6f3e031b55953acdb227a28431c6">eSleepType</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a slot for timed event and store it. </p>
<p>This is actual execution core for both <a class="el" href="group__os__timer.html#ga579228f0ea6911563f3c09d50b0f441d">os_usleep</a> and <a class="el" href="group__os__timer.html#gad144032be21d6335801e51f3668d62d7">os_setitimer</a> functions. It will find free slot or slot already occupied by calling thread and will set / update timeout values. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">microseconds</td><td>time for which thread should sleep / wait for event </td></tr>
    <tr><td class="paramname">type</td><td>type of timed event to set up </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>error status. 0 means no error. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="gaa0e811d6349480297cbad82c700077de" name="gaa0e811d6349480297cbad82c700077de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0e811d6349480297cbad82c700077de">&#9670;&#160;</a></span>sleepers</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structTimerEntry__t.html">TimerEntry_t</a> sleepers[<a class="el" href="group__os__config.html#gac1843ed039050da6d9253cfba6ed8caa">SLEEPERS_MAX</a>]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>List of all delays requested from kernel. </p>
<p>This structure contains all scheduled sleeps requested by all threads. Every thread can technically request one periodic timer and one one-shot delay. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.7-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</div>
</body>
</html>
