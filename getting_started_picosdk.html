<!-- HTML header for doxygen 1.9.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>C Microkernel Realtime eXecutive: HOWTO: Integrating CMRX into Pico-SDK project</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="all">
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">C Microkernel Realtime eXecutive
   </div>
   <div id="projectbrief">Realtime Operating System for Cortex-M based microcontrollers</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('getting_started_picosdk.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">HOWTO: Integrating CMRX into Pico-SDK project</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Following is a step-by-step how to guide on creating a blinky project using CMRX RTOS. It will cover all steps and lists all tools needed to complete the integration. This guide assumes previous hands-on experience with creating embedded firmware, including the process of flashing and debugging. Basic understanding of CMake is assumed.</p>
<p>As an example, this howto will demonstrate the process of integrating CMRX into project using Raspberry Pi Pico-SDK on RP2040 microcontroller. CMRX is flexible and supports virtually all microcontrollers with CMSIS headers available in their SDK/HAL. Thus this howto will avoid using vendor-specific build tools / IDEs to make the guide as portable as possible.</p>
<p>This example will demonstrate creation of basic blinky example using SysTick timer as the kernel timing provider.</p>
<h1><a class="anchor" id="autotoc_md59"></a>
Prerequisites</h1>
<p>In order to generate and build the project, following tools are required: </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Name   </th><th class="markdownTableHeadNone">Min. Supported Version   </th><th class="markdownTableHeadNone">Note    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">CMake   </td><td class="markdownTableBodyNone">3.22.0   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Python   </td><td class="markdownTableBodyNone">3.0   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">ARM GCC toolchain   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Native GCC toolchain   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">needed for unit test build, optional    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">GNU Make / Ninja   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Git   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td></tr>
</table>
<p>All the above tools need to be installed and available in execution path otherwise various parts of the configure and/or build process may fail. Note that if these tools are installed via default distribution mechanisms, they are usually available in execution path. If you install them manually, you may have add them to path as well.</p>
<p>Following is the list of additional tools required only by this guide. They are project / MCU specific or can be replaced by tools of your choice (e.g. IDE of your choice).</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Name   </th><th class="markdownTableHeadNone">Min. Supported Version   </th><th class="markdownTableHeadNone">Note    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Pico-SDK   </td><td class="markdownTableBodyNone">2.0.0   </td><td class="markdownTableBodyNone">older versions might work, but need adjustments    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">OpenOCD   </td><td class="markdownTableBodyNone">0.12.0   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">GDB   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">must be a multiarch build supporting AArch32   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md63"></a>
Creating Project Skeleton</h1>
<p>Pico-SDK is CMake-based SDK for the range of microcontrollers designed by the Raspberry Pi Foundation. So for the skeleton, we have to create the CMakeLists.txt file. Yet, before we do so, lets first clone the CMRX source tree so we know some of paths we'll need in the folling process. This how-to will assume that the path where project is stored is <code>$HOME/projects/pico-sdk-example</code>.</p>
<div class="fragment"><div class="line">mkdir -p ~/projects/pico-sdk-example</div>
<div class="line">cd ~/project/pico-sdk-example</div>
<div class="line">git init</div>
<div class="line">git submodule add https://github.com/ventZl/cmrx.git</div>
<div class="line">git submodule add https://github.com/raspberrypi/pico-sdk.git</div>
<div class="line">git submodule update --init --recursive</div>
</div><!-- fragment --><p>This will initialize empty Git repository and create <code>cmrx</code> subdirectory containing the up-to-date source tree of CMRX RTOS.</p>
<p>Lets start with CMakeLists skeleton as it is published in the <code>Getting started with Raspberry Pi-Pico series</code> in Appendix C:</p>
<div class="fragment"><div class="line">cmake_minimum_required(VERSION 3.13)</div>
<div class="line"> </div>
<div class="line">include(pico_sdk_import.cmake)</div>
<div class="line">project(blinky C CXX ASM)</div>
<div class="line"> </div>
<div class="line">set(CMAKE_C_STANDARD 11)</div>
<div class="line">set(CMAKE_CXX_STANDARD 17)</div>
<div class="line"> </div>
<div class="line">pico_sdk_init()</div>
<div class="line"> </div>
<div class="line">add_executable(pico-sdk-example</div>
<div class="line">  src/main.c</div>
<div class="line">)</div>
<div class="line">pico_add_extra_outputs(pico-sdk-example)</div>
<div class="line">target_link_libraries(pico-sdk-example pico_stdlib)</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md65"></a>
Integrating CMRX into Pico-SDK project</h1>
<p>Following steps will integrate CMRX RTOS into project we just created, make sure that CMRX will use the Pico-SDK and we will add a simply blinky application.</p>
<h2><a class="anchor" id="autotoc_md66"></a>
1. Add CMake modules provided by CMRX and Pico-SDK into CMake module path</h2>
<p>First, we'll set some paths to make things more convenient. While we know that we submoduled both CMRX and Pico-SDK, we can add following lines to put both Pico-SDK and CMRX cmake subdirectories into CMake module search path:</p>
<div class="fragment"><div class="line">set(PICO_SDK_PATH ${CMAKE_SOURCE_DIR}/pico-sdk)</div>
<div class="line">list(APPEND CMAKE_MODULE_PATH &quot;${PICO_SDK_PATH}/external&quot;)</div>
<div class="line">list(APPEND CMAKE_MODULE_PATH &quot;${CMAKE_SOURCE_DIR}/cmrx/cmake&quot;)</div>
</div><!-- fragment --><p>Now you can update the line which imports pico_sdk to be:</p>
<div class="fragment"><div class="line">include(pico_sdk_import)</div>
</div><!-- fragment --><p>This way we don't need to copy it over into our source tree.</p>
<h2><a class="anchor" id="autotoc_md67"></a>
2. Configuring Pico-SDK integration</h2>
<p>Instead of providing microcontroller-specific ports, CMRX relies on generic architecture support. For ARM Cortex-M this is possible due to the CMSIS device headers available for virtually all microcontrollers. CMRX can run on any microcontroller whose SDK/HAL provides these headers. Pico-SDK does provide them.</p>
<p>To make the job easier, the ARM architecture support package provides <code>FindCMSIS</code> CMake module. This module will find necessary CMSIS components and configure the kernel to use them. To be able to do so efficiently, you need to provide it with some basic configuration details.</p>
<p>Lets add <code>FindCMSIS</code> into the <code>CMakeLists.txt</code>. Add the following block after the previous one:</p>
<div class="fragment"><div class="line">set(CMSIS_ROOT ${PICO_SDK_PATH}/src/rp2_common/cmsis/stub/CMSIS)</div>
<div class="line">set(DEVICE RP2040)</div>
<div class="line">set(CMSIS_LINKER_FILE ${PICO_SDK_PATH}/src/rp2_common/pico_crt0/rp2040/memmap_default.ld)</div>
<div class="line">include(FindCMSIS)</div>
</div><!-- fragment --><p>This block configures a few variables and then includes the <code>FindCMSIS</code> module. These variables contain the following information:</p>
<ul>
<li><code>CMSIS_ROOT</code> - path to where CMSIS headers are stored within HAL/SDK sources. This depends on the HAL/MCU used. This variable is mandatory.</li>
<li><code>DEVICE</code> - the name of microcontroller used. CMSIS headers require this variable to be set in order to provide correct definitions. Use the device name as supported by your HAL/SDK. This variable is mandatory.</li>
<li><code>CMSIS_LINKER_FILE</code> - path to the linker file used by the project. The actual path to the linker file may vary. Certain SDKs/HALs provide fixed linker scripts that are shipped with the SDK, some (such as CubeMX) will generate linker script based on project configuration. This variable is mandatory and must point to existing file.</li>
<li><code>SYSTEM_INCLUDE_FILENAME</code> - this variable is optional. It may be needed in case that the CMSIS system include file does not match your DEVICE name. Normally, the system include filename should be system_&lt;$DEVICE&gt;.h but that's often not the case. If your HAL uses different naming pattern (CubeMX often does) then you have to provide the name of this header.</li>
</ul>
<p>Once all the variables are set, we can include FindCMSIS that will configure the ARM architecture support to use the CubeMX HAL.</p>
<h2><a class="anchor" id="autotoc_md68"></a>
3. Configuring CMRX kernel to use Pico-SDK</h2>
<p>The last step needed is to configure the kernel to actually use the configuration determined by the <code>FindCMSIS</code> module. This is actually rather simple. Again modify the <code>CMakeLists.txt</code> file. This time, add the following block just below the line that calls <code>pico_sdk_init</code>:</p>
<div class="fragment"><div class="line">set(CMRX_ARCH arm)</div>
<div class="line">set(CMRX_HAL cmsis)</div>
<div class="line">include(CMRX)</div>
</div><!-- fragment --><p>This block tells the CMRX kernel, that it is expected to build for ARM architecture and that the HAL used is "CMSIS-compatible". This configuration will work as the <code>FindCMSIS</code> module found and recorded all the necessary HAL components.</p>
<p>The next step is to add the CMRX source tree so the kernel will actually be built using the given configuration. To achieve this, add one line, just below the block just inserted:</p>
<div class="fragment"><div class="line">add_subdirectory(cmrx)</div>
</div><!-- fragment --><p>This will tell CMake, that in subdirectory <code>cmrx</code> there is another part of the current project. This directory comes from CMRX git repository and contains its own CMakeLists.txt suitable for embedding into other projects.</p>
<h1><a class="anchor" id="autotoc_md69"></a>
Linking CMRX to the project</h1>
<p>Now your project contains a buildable instance of the CMRX kernel, but the kernel is not used by your project yet. In order to achieve this a few more modifications are needed.</p>
<p>CMRX itself is built as a static library called <code>cmrx</code>. In order to use CMRX, you have to link this library to your project. Additionally, CMRX performs linker script management. This is necessary to make memory protection work seamlessly. To achieve this a special, CMRX-specific command exists: <code>add_firmware</code>.</p>
<p>This command is a wrapper around <code>add_executable</code> normally used to define firmware files that adds post-build target to update linker scripts.</p>
<p>Lets start by linking CMRX library to the main executable: At the very bottom of the CMakeLists.txt there is <code>target_link_libraries</code> command. Update it to look like this:</p>
<div class="fragment"><div class="line">target_link_libraries(pico-sdk-example cmrx aux_systick pico_stdlib cmsis_core)</div>
</div><!-- fragment --><p>While we were here, we added one additional library - <code>aux_systick</code>. Library <code>aux_systick</code> contains the implementation of SysTick-based kernel timing provider. The reason why it is implemented as a separate library is, that CMRX allows you to implement your own timing provider if you want to use some other timing source, e.g. for low power applications where SysTick is going to be shut down.</p>
<p>Next, find the line:</p>
<div class="fragment"><div class="line">add_executable(pico-sdk-example</div>
</div><!-- fragment --><p>And change it to:</p>
<div class="fragment"><div class="line">add_firmware(pico-sdk-example</div>
</div><!-- fragment --><p>Your CMakeLists.txt should now look like this:</p>
<div class="fragment"><div class="line">cmake_minimum_required(VERSION 3.13)</div>
<div class="line"> </div>
<div class="line">set(PICO_SDK_PATH ${CMAKE_SOURCE_DIR}/pico-sdk)</div>
<div class="line">list(APPEND CMAKE_MODULE_PATH &quot;${PICO_SDK_PATH}/external&quot;)</div>
<div class="line">list(APPEND CMAKE_MODULE_PATH &quot;${CMAKE_SOURCE_DIR}/cmrx/cmake&quot;)</div>
<div class="line"> </div>
<div class="line">include(pico_sdk_import)</div>
<div class="line"> </div>
<div class="line">project(blinky C CXX ASM)</div>
<div class="line"> </div>
<div class="line">set(CMAKE_C_STANDARD 11)</div>
<div class="line">set(CMAKE_CXX_STANDARD 17)</div>
<div class="line"> </div>
<div class="line">set(CMSIS_ROOT ${PICO_SDK_PATH}/src/rp2_common/cmsis/stub/CMSIS)</div>
<div class="line">set(DEVICE RP2040)</div>
<div class="line">set(CMSIS_LINKER_FILE ${PICO_SDK_PATH}/src/rp2_common/pico_crt0/rp2040/memmap_default.ld)</div>
<div class="line">include(FindCMSIS)</div>
<div class="line"> </div>
<div class="line">pico_sdk_init()</div>
<div class="line"> </div>
<div class="line">set(CMRX_ARCH arm)</div>
<div class="line">set(CMRX_HAL cmsis)</div>
<div class="line">include(CMRX)</div>
<div class="line"> </div>
<div class="line">add_subdirectory(cmrx)</div>
<div class="line"> </div>
<div class="line"># Here we changed the call add_executable to add_firmware</div>
<div class="line">add_firmware(</div>
<div class="line">    pico-sdk-example src/main.c</div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line">pico_add_extra_outputs(pico-sdk-example)</div>
<div class="line">target_link_libraries(pico-sdk-example cmrx aux_systick pico_stdlib cmsis_core)</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md70"></a>
Creating main.c file</h1>
<p>Next we need a main file that will actually start out RTOS. This file is in fact very short:</p>
<div class="fragment"><div class="line">#include &lt;extra/systick.h&gt;</div>
<div class="line">#include &lt;cmrx/cmrx.h&gt;</div>
<div class="line">#include &lt;RTE_Components.h&gt;</div>
<div class="line">#include CMSIS_device_header</div>
<div class="line"> </div>
<div class="line">long timing_get_current_cpu_freq(void)</div>
<div class="line">{</div>
<div class="line">    return SystemCoreClock;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">int main(void)</div>
<div class="line">{</div>
<div class="line">    timing_provider_setup(1);</div>
<div class="line">    os_start();</div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>What does it do? Lets go bottom - up:</p>
<p>The last function call - <code><a class="el" href="group__os.html#gac0d275303ced3f7617b7d71fd1464687">os_start()</a></code> starts the operating system kernel. When this is done, it will execute some of our threads. Yet, before this may happen, we need to initialize the timing provider library, we included into project earlier. This is done by calling <code><a class="el" href="group__aux__systick.html#gac72eb3fe338346006ca3089ca0898867" title="Setup the timing provider.">timing_provider_setup()</a></code>, giving it argument 1, which means that threads will be switched once every millisecond.</p>
<p>Now, while the timing provider is not chip-specific, it needs some way to determine the CPU speed. There isn't any default way of doing so, instead, there is a callback you have to provide, that returns this frequency. While we are using CMSIS headers, we can rely on the <code>SystemCoreClock</code> variable which holds this information. So our implementation of the callback will simply return this value.</p>
<p>Provide a way how timing provider can learn CPU frequency, initialize it and then start the kernel. Three easy steps to start the kernel.</p>
<h1><a class="anchor" id="autotoc_md71"></a>
Creating the blinky application</h1>
<p>Blinky application does a simple thing: it periodically turns a LED diode on and off. We will implement blinky as a CMRX userspace application. The advantage of this design is that blinky will be isolated from the rest of the system by the MPU. This means that a memory access error can't damage kernel nor any other task in the system.</p>
<p>Lets start by creating a skeleton of the application. First, create a directory <code>src/blinky</code>. The exact path does not matter but lets keep things nice and tidy and create blinky its own directory. In this directory, create two files: <code>src/blinky/CMakeLists.txt</code>:</p>
<div class="fragment"><div class="line">set(blinky_SRCS blinky.c)</div>
<div class="line">add_application(blinky ${blinky_SRCS})</div>
<div class="line">target_link_libraries(blinky PRIVATE stdlib pico_stdlib_headers)</div>
</div><!-- fragment --><p>This <code>CMakeLists.txt</code> file contains CMRX-specific command <code>add_application()</code> which is a wrapper around <code>add_library()</code> command. It ensures that proper linker script management is performed. Next this application links against several libraries. First is <code>stlib</code> - a standard library that gives the application access to the system call interface. Another one is a library we will cover later in this guide. Now you need to know that this library exports information on CubeMX HAL include paths and defines.</p>
<p>The source code of <code>src/blinky/blinky.c</code> will be a bit more verbose than usual. Aside from defining the main function for the blinky application, we also need to define the application itself. Moreover, as said above, CMRX will make sure that the blinky application can only access its own private data and nothing else. The problem is that blinky, in its nature, behaves as a device driver - it makes access to GPIO ports in order to light up LEDs.</p>
<p>So the code in <code>blinky.c</code> will do four things:</p><ul>
<li>define main function for the blinky application</li>
<li>define the blinky application so CMRX knows that there is such application</li>
<li>grant the blinky application access to GPIO ports</li>
<li>define a thread that will be automatically started, running the main function for the blinky application</li>
</ul>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cmrx/application.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;pico/stdlib.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cmrx/ipc/timer.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Main function for the blinky application */</span></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span> blinky_main(<span class="keywordtype">void</span> * data)</div>
<div class="line">{</div>
<div class="line">    (void) data;</div>
<div class="line">    gpio_init(PICO_DEFAULT_LED_PIN);</div>
<div class="line">    gpio_set_dir(PICO_DEFAULT_LED_PIN, GPIO_OUT);</div>
<div class="line">    <span class="keywordflow">while</span> (1) {</div>
<div class="line">        gpio_put(PICO_DEFAULT_LED_PIN, 1);</div>
<div class="line">        <a class="code hl_function" href="group__api__timer.html#ga6987ccb3233088dddefcf26bb39f249a">usleep</a>(500000);</div>
<div class="line">        gpio_put(PICO_DEFAULT_LED_PIN, 0);</div>
<div class="line">        <a class="code hl_function" href="group__api__timer.html#ga6987ccb3233088dddefcf26bb39f249a">usleep</a>(500000);</div>
<div class="line"> </div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Grant the blinky application access to the GPIO peripheral */</span></div>
<div class="line"><a class="code hl_define" href="group__api__init.html#gaef7fd4ff3de50fb8b7bb9d5b51363278">OS_APPLICATION_MMIO_RANGES</a>(blinky, 0x40000000, 0x50000000, 0xd0000000, 0xe0000000);</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Declare the blinky application */</span></div>
<div class="line"><a class="code hl_define" href="group__api__init.html#gab5f63b29702312bedfe955e8465891cd">OS_APPLICATION</a>(blinky);</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Tell CMRX to automatically start a thread using `blinky_main` as an</span></div>
<div class="line"><span class="comment"> * entrypoint and having thread priority of 32 */</span></div>
<div class="line"><a class="code hl_define" href="group__api__init.html#gab0cfed2a7b7800c9b487db972328ef5d">OS_THREAD_CREATE</a>(blinky, blinky_main, <a class="code hl_define" href="group__api.html#ga070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, 32);</div>
<div class="ttc" id="agroup__api__init_html_gab0cfed2a7b7800c9b487db972328ef5d"><div class="ttname"><a href="group__api__init.html#gab0cfed2a7b7800c9b487db972328ef5d">OS_THREAD_CREATE</a></div><div class="ttdeci">#define OS_THREAD_CREATE(application, entrypoint, data, priority, core)</div><div class="ttdoc">Thread autostart facility.</div><div class="ttdef"><b>Definition</b> application.h:92</div></div>
<div class="ttc" id="agroup__api__init_html_gab5f63b29702312bedfe955e8465891cd"><div class="ttname"><a href="group__api__init.html#gab5f63b29702312bedfe955e8465891cd">OS_APPLICATION</a></div><div class="ttdeci">#define OS_APPLICATION(application)</div><div class="ttdoc">Declare userspace process.</div><div class="ttdef"><b>Definition</b> application.h:58</div></div>
<div class="ttc" id="agroup__api__init_html_gaef7fd4ff3de50fb8b7bb9d5b51363278"><div class="ttname"><a href="group__api__init.html#gaef7fd4ff3de50fb8b7bb9d5b51363278">OS_APPLICATION_MMIO_RANGES</a></div><div class="ttdeci">#define OS_APPLICATION_MMIO_RANGES(application, from, to, from2, to2)</div><div class="ttdef"><b>Definition</b> application.h:43</div></div>
<div class="ttc" id="agroup__api__timer_html_ga6987ccb3233088dddefcf26bb39f249a"><div class="ttname"><a href="group__api__timer.html#ga6987ccb3233088dddefcf26bb39f249a">usleep</a></div><div class="ttdeci">__SYSCALL int usleep(unsigned microseconds)</div><div class="ttdoc">Suspend thread execution for short time.</div><div class="ttdef"><b>Definition</b> timer.c:4</div></div>
<div class="ttc" id="agroup__api_html_ga070d2ce7b6bb7e5c05602aa8c308d0c4"><div class="ttname"><a href="group__api.html#ga070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a></div><div class="ttdeci">#define NULL</div><div class="ttdoc">Name the null pointer.</div><div class="ttdef"><b>Definition</b> defines.h:68</div></div>
</div><!-- fragment --><p>Note that the name <code>blinky</code> used in macros inside <code>blinky.c</code> must be the same as the name <code>blinky</code> used in the <code>add_application()</code> function in CMakeLists.txt.</p>
<p>If the name differs then the build will fail as CMRX expects that these two names match.</p>
<p>The macro <code>OS_APPLICATION_MMIO_RANGES</code> allows to define up to two arbitrary ranges of memory accessible to the application. These ranges are defined by a pair of starting and ending address. Without specifying the address range of GPIO peripherals blinky won't be able to blink the LED.</p>
<p>Addresses passed to this macro have several rules imposed by the CPU itself:</p><ul>
<li>Block size (end address - start address) must be a power of two value larger than 256</li>
<li>Start address must be aligned to size of the block. This means that if block size is e.g. 256, then the start address must have alignment of 256 bytes.</li>
</ul>
<h1><a class="anchor" id="autotoc_md72"></a>
Adding blinky application to the build</h1>
<p>Very last step is to add this application to the build. To do so, two lines have to be added into master <code>CMakeLists.txt</code>.</p>
<p>Just after the line </p><div class="fragment"><div class="line">add_subdirectory(cmrx)</div>
</div><!-- fragment --><p>add another line: </p><div class="fragment"><div class="line">add_subdirectory(src/blinky)</div>
</div><!-- fragment --><p>This will add source code for the blinky application into the build.</p>
<p>To include the blinky application into the firmware, we need to link it to the application. This is done using CMRX-specific command <code>target_add_applications()</code>. This command is essentially a wrapper around <code>target_link_libraries()</code> that automatically manages linker scripts. Add following line at the very end of the <code>CMakeLists.txt</code>:</p>
<div class="fragment"><div class="line">target_add_applications(pico-sdk-example</div>
<div class="line">    blinky</div>
<div class="line">)</div>
</div><!-- fragment --><p>This is it! You have created your first fully memory protected application running on top of CMRX operating system. You can build the project now. You should get file <code>build/pico-sdk-example.elf</code> which contains the application firmware.</p>
<h1><a class="anchor" id="autotoc_md73"></a>
Flashing the application</h1>
<p>There are multiple ways of flashing the firmware available. This guide will use one of IDE-agnostic ways: direct use of openocd and gdb.</p>
<p>OpenOCD is a gateway between your debugger probe and the debugger used on your PC.</p>
<p>Proceed by connecting your Nucleo board (ST-Link side) to the computer via USB. Make sure that ST-Link probe is visible by the operating system.</p>
<p>Now execute the following command in terminal:</p>
<div class="fragment"><div class="line">openocd -f interface/cmsis-dap.cfg -f target/rp2040.cfg</div>
</div><!-- fragment --><p>This will start openocd and connect it to your Picoprobe, detect the connected CPU and wait for connection by debugger.</p>
<p>Next, once your firmware is built, run GDB in another terminal:</p>
<div class="fragment"><div class="line">gdb ~/projects/pico-sdk-example/build/pico-sdk-example.elf</div>
</div><!-- fragment --><p>In this GDB instance, the following sequence of commands will perform following actions: 1) GDB will connect to the OpenOCD which will serve as GDB server and provide connection to the CPU on your Nucleo board 2) Load the CPU on the Nucleo board with the firmware just built 3) Start executing the firmware</p>
<div class="fragment"><div class="line">target extended-remote localhost:3333</div>
<div class="line">load</div>
<div class="line">run</div>
</div><!-- fragment --><p>If you did everything correctly, you should see that the green LED on the Nucleo board will blink roughly in 0.5 second interval.</p>
<p>Congratulations! You have just successfully created, built and flashed your first CMRX-based project! </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.7-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</div>
</body>
</html>
