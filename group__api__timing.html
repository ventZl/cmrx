<!-- HTML header for doxygen 1.9.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>C Microkernel Realtime eXecutive: Timing provider API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="all">
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">C Microkernel Realtime eXecutive
   </div>
   <div id="projectbrief">Realtime Operating System for Cortex-M based microcontrollers</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__api__timing.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Timing provider API<div class="ingroups"><a class="el" href="group__api.html">Kernel API</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>API providing clock source to the kernel.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaa382f230650e9c08f3d5dec13da6fbd4" id="r_gaa382f230650e9c08f3d5dec13da6fbd4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__api__timing.html#gaa382f230650e9c08f3d5dec13da6fbd4">timing_provider_schedule</a> (long <a class="el" href="group__os__timer.html#ga5a54481fa8804be03b96cbc5d85ec03b">delay_us</a>)</td></tr>
<tr class="memdesc:gaa382f230650e9c08f3d5dec13da6fbd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule next timer callback to kernel.  <br /></td></tr>
<tr class="separator:gaa382f230650e9c08f3d5dec13da6fbd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32ca98f569fe077cd53c29a5417f80de" id="r_ga32ca98f569fe077cd53c29a5417f80de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__api__timing.html#ga32ca98f569fe077cd53c29a5417f80de">timing_provider_delay</a> (long <a class="el" href="group__os__timer.html#ga5a54481fa8804be03b96cbc5d85ec03b">delay_us</a>)</td></tr>
<tr class="memdesc:ga32ca98f569fe077cd53c29a5417f80de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform tight busy-wait delay.  <br /></td></tr>
<tr class="separator:ga32ca98f569fe077cd53c29a5417f80de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7613a35fc20c795f3fcfe3042100769" id="r_gaa7613a35fc20c795f3fcfe3042100769"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__api__timing.html#gaa7613a35fc20c795f3fcfe3042100769">timing_get_current_cpu_freq</a> (void)</td></tr>
<tr class="memdesc:gaa7613a35fc20c795f3fcfe3042100769"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide information on the current CPU speed.  <br /></td></tr>
<tr class="separator:gaa7613a35fc20c795f3fcfe3042100769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2eee99d75e6b65c227f65a6880f2e9f" id="r_gad2eee99d75e6b65c227f65a6880f2e9f"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__api__timing.html#gad2eee99d75e6b65c227f65a6880f2e9f">os_sched_timing_callback</a> (long <a class="el" href="group__os__timer.html#ga5a54481fa8804be03b96cbc5d85ec03b">delay_us</a>)</td></tr>
<tr class="memdesc:gad2eee99d75e6b65c227f65a6880f2e9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kernel callback for timing provider.  <br /></td></tr>
<tr class="separator:gad2eee99d75e6b65c227f65a6880f2e9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>API providing clock source to the kernel. </p>
<p>CMRX kernel needs source of clock to perform certain tasks, such as preemptive multi-threading and reliable implementation of delays and timers. This resource is not provided by the kernel itself. It is a task of the integrator to provide suitable implementation of calls which form the API of timing provider. This gives the integrator a possibility to choose the source of clock which suits his intended purposes the best.</p>
<p>The design of timing provider API is done in a way that it is possible to implement CPU core power management here as the call directly informs the integrator on how long the kernel is not expecting any CPU activity. Integrator is free to perform the delay in any way available on the target HW, including shutting down the CPU as long as the method implemented is able to resume CPU operation in requested time or very close to it.</p>
<p>Kernel source tree provides <a class="el" href="group__aux__systick.html">SysTick-Based Timing Provider</a> based on ARM Cortex-M SysTick peripheral. This implementation lacks any form of power management as the SysTick peripheral is only running if CPU clock is also running. It can be used to bootstrap the kernel on the target HW or debug problems with more complex timing providers.</p>
<h1><a class="anchor" id="Overview"></a>
Overview</h1>
<p>The timing provider API allows kernel to perform two basic operations:</p><ul>
<li>short term precise synchronous delays</li>
<li>long term asynchronous delays involving power management</li>
</ul>
<p>The reason why kernel is using the timing provider API for both tasks is, that it doesn't know the hardware it is running on. Implementation of clocks and power management differs from chip to chip and it would be limiting to impose some way of clock control. Rather, the kernel provides simple API the integrator can implement to best suite his purposes.</p>
<h1><a class="anchor" id="sync_delay"></a>
Precise synchronous delays</h1>
<p>This kind of delays is used whenever kernel assumes that the delay timing is too short to perform any other task. This typically happens with short - microsecond range - delays in implementations of various protocols.</p>
<p>The integrator has to provide an implementation of this call which performs as precise delay, as possible. This delay can be implemented as busy-wait and will be called in privileged kernel mode. Integrator should consider possible CPU power states (mainly the current CPU frequency) to perform the delay correctly.</p>
<h1><a class="anchor" id="async_delay"></a>
Asynchronous delays involving power management</h1>
<p>This kind of delay is used when kernel needs to be notified that certain amount of time has passed. This call is asynchronous in terms that the timing provider shall return immediately after it sets up timer to trigger after certain amount of time.</p>
<p>Once the hardware timer triggers the delay, the timing provider shall call the <a class="el" href="group__api__timing.html#gad2eee99d75e6b65c227f65a6880f2e9f">os_sched_timing_callback()</a> of the kernel notifying it, that given amount of time has passed. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="gad2eee99d75e6b65c227f65a6880f2e9f" name="gad2eee99d75e6b65c227f65a6880f2e9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad2eee99d75e6b65c227f65a6880f2e9f">&#9670;&#160;</a></span>os_sched_timing_callback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long os_sched_timing_callback </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>delay_us</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Kernel callback for timing provider. </p>
<p>Kernel entrypoint for timed events. Kernel tells the timing provider, what is the delay before the next call, whenever this function is called. Timing provider shall then wait for given amount of time and then call this callback again. If the delay is 0, then timing provider can shutdown itself as there is no expected timed wakeup. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">delay_us</td><td>the actual amount of microseconds which happened since the last wakeup </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>amount of microseconds, which shall pass before next wakeup will happen. If this value is zero, then no next wakeup shall happen. </dd></dl>

</div>
</div>
<a id="gaa7613a35fc20c795f3fcfe3042100769" name="gaa7613a35fc20c795f3fcfe3042100769"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa7613a35fc20c795f3fcfe3042100769">&#9670;&#160;</a></span>timing_get_current_cpu_freq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long timing_get_current_cpu_freq </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provide information on the current CPU speed. </p>
<p>This call should return the current CPU speed in Hz. The kernel itself does not need to know this information as it outsources all the timing duties to the timing provider. Userspace applications and drivers might need to know this. As they all run in the userspace, typically it is not possible to access this information directly. Thus this system call is provided to make this information accessible in the userspace. </p><dl class="section return"><dt>Returns</dt><dd>Current CPU speed in Hz, or 0 if this value is not available or reliable. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is guarranteed to be called from kernel context. </dd></dl>

</div>
</div>
<a id="ga32ca98f569fe077cd53c29a5417f80de" name="ga32ca98f569fe077cd53c29a5417f80de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga32ca98f569fe077cd53c29a5417f80de">&#9670;&#160;</a></span>timing_provider_delay()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void timing_provider_delay </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>delay_us</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform tight busy-wait delay. </p>
<p>Kernel calls this function whenever tight delay is required. If delays are in orders of microseconds, then it usually makes no sense to yield or try to do anything else because the overhead of thread switching will consume all the time. Timing timing provider shall perform busy-wait delay, waiting for given amount of microseconds. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">delays_ns</td><td>amount of microseconds to wait before resuming execution </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is guarranteed to be called from kernel context. </dd></dl>

</div>
</div>
<a id="gaa382f230650e9c08f3d5dec13da6fbd4" name="gaa382f230650e9c08f3d5dec13da6fbd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa382f230650e9c08f3d5dec13da6fbd4">&#9670;&#160;</a></span>timing_provider_schedule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void timing_provider_schedule </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>delay_us</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Schedule next timer callback to kernel. </p>
<p>Re-configure timing provider so that next timed kernel call will happen after given delay. This is the only function, whose implementation is mandatory and whose prototype nor behavior cannot be changed. If kernel calls this function, then timing provider must reconfigure itself so that it will be able to call the kernel as close as possible to time <a class="el" href="group__os__timer.html#ga5a54481fa8804be03b96cbc5d85ec03b">delay_us</a> microseconds in the future. This must happen even if kernel previously signalized that there is no expected timed event and timers were turned off entirely. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">delay_us</td><td>delay time, in microseconds after which kernel shall be called by the timing provider. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is guarranteed to be called from kernel context. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.7-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</div>
</body>
</html>
