<!-- HTML header for doxygen 1.9.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>C Microkernel Realtime eXecutive: Remote Procedure Calls</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="all">
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">C Microkernel Realtime eXecutive
   </div>
   <div id="projectbrief">Realtime Operating System for Cortex-M based microcontrollers</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__os__rpc.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Remote Procedure Calls<div class="ingroups"><a class="el" href="group__os.html">Kernel documentation</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>This kernel implementation of RPC mechanism.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRPC__Service__t__.html">RPC_Service_t_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic structure of any RPC object.  <a href="structRPC__Service__t__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gac23283a15be44b1f8451954379b2c723" id="r_gac23283a15be44b1f8451954379b2c723"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__rpc.html#gac23283a15be44b1f8451954379b2c723">E_VTABLE_UNKNOWN</a>&#160;&#160;&#160;0xFF</td></tr>
<tr class="memdesc:gac23283a15be44b1f8451954379b2c723"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant denoting that the VTable pointer is not valid.  <br /></td></tr>
<tr class="separator:gac23283a15be44b1f8451954379b2c723"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga1c1678be361051059ce59465b10e1c39" id="r_ga1c1678be361051059ce59465b10e1c39"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structRPC__Service__t__.html">RPC_Service_t_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__rpc.html#ga1c1678be361051059ce59465b10e1c39">RPC_Service_t</a></td></tr>
<tr class="separator:ga1c1678be361051059ce59465b10e1c39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac47babdf383d8e134907594b7205796e" id="r_gac47babdf383d8e134907594b7205796e"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__rpc.html#gac47babdf383d8e134907594b7205796e">RPC_Method_t</a>) (<a class="el" href="group__os__rpc.html#ga1c1678be361051059ce59465b10e1c39">RPC_Service_t</a> *service, unsigned arg0, unsigned arg1, unsigned arg2, unsigned arg3)</td></tr>
<tr class="memdesc:gac47babdf383d8e134907594b7205796e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calling signature of a RPC call.  <br /></td></tr>
<tr class="separator:gac47babdf383d8e134907594b7205796e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcd71cb246a9a05989ca78eb79175239" id="r_gadcd71cb246a9a05989ca78eb79175239"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__os__rpc.html#gac47babdf383d8e134907594b7205796e">RPC_Method_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__rpc.html#gadcd71cb246a9a05989ca78eb79175239">VTable_t</a></td></tr>
<tr class="memdesc:gadcd71cb246a9a05989ca78eb79175239"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type definition of VTable.  <br /></td></tr>
<tr class="separator:gadcd71cb246a9a05989ca78eb79175239"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gab6a04c90d0385e2685fb5e494af298ff" id="r_gab6a04c90d0385e2685fb5e494af298ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__api.html#ga36958e2082eecb09f367fa4aa3a9a84d">Process_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__rpc.html#gab6a04c90d0385e2685fb5e494af298ff">get_vtable_process</a> (<a class="el" href="group__os__rpc.html#gadcd71cb246a9a05989ca78eb79175239">VTable_t</a> *vtable)</td></tr>
<tr class="memdesc:gab6a04c90d0385e2685fb5e494af298ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identify process which owns the VTable.  <br /></td></tr>
<tr class="separator:gab6a04c90d0385e2685fb5e494af298ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26f43d83332c3aca17beb91973e59156" id="r_ga26f43d83332c3aca17beb91973e59156"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__rpc.html#ga26f43d83332c3aca17beb91973e59156">rpc_stack_push</a> (<a class="el" href="group__api.html#ga36958e2082eecb09f367fa4aa3a9a84d">Process_t</a> process_id)</td></tr>
<tr class="memdesc:ga26f43d83332c3aca17beb91973e59156"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add new process ID to the stack of RPC calls.  <br /></td></tr>
<tr class="separator:ga26f43d83332c3aca17beb91973e59156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6cf8081b66bf611d61c09b161af5501" id="r_gae6cf8081b66bf611d61c09b161af5501"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__rpc.html#gae6cf8081b66bf611d61c09b161af5501">rpc_stack_pop</a> ()</td></tr>
<tr class="memdesc:gae6cf8081b66bf611d61c09b161af5501"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the last entry in the RPC stack.  <br /></td></tr>
<tr class="separator:gae6cf8081b66bf611d61c09b161af5501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34f4075561574cff1c35a7b4913f2105" id="r_ga34f4075561574cff1c35a7b4913f2105"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__api.html#ga36958e2082eecb09f367fa4aa3a9a84d">Process_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__rpc.html#ga34f4075561574cff1c35a7b4913f2105">rpc_stack_top</a> ()</td></tr>
<tr class="memdesc:ga34f4075561574cff1c35a7b4913f2105"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the topmost process ID in thread's RPC call stack.  <br /></td></tr>
<tr class="separator:ga34f4075561574cff1c35a7b4913f2105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ee8f29f3009ad125af02a612603504f" id="r_ga9ee8f29f3009ad125af02a612603504f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__rpc.html#ga9ee8f29f3009ad125af02a612603504f">os_rpc_call</a> (uint32_t arg0, uint32_t arg1, uint32_t arg2, uint32_t arg3)</td></tr>
<tr class="memdesc:ga9ee8f29f3009ad125af02a612603504f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kernel implementation of rpc_call syscall.  <br /></td></tr>
<tr class="separator:ga9ee8f29f3009ad125af02a612603504f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b0268c1c8ecd0d6e3194f0f52be350c" id="r_ga2b0268c1c8ecd0d6e3194f0f52be350c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__os__rpc.html#ga2b0268c1c8ecd0d6e3194f0f52be350c">os_rpc_return</a> (uint32_t arg0, uint32_t arg1, uint32_t arg2, uint32_t arg3)</td></tr>
<tr class="memdesc:ga2b0268c1c8ecd0d6e3194f0f52be350c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kernel implementation of rpc_return syscall.  <br /></td></tr>
<tr class="separator:ga2b0268c1c8ecd0d6e3194f0f52be350c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>This kernel implementation of RPC mechanism. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gac23283a15be44b1f8451954379b2c723" name="gac23283a15be44b1f8451954379b2c723"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac23283a15be44b1f8451954379b2c723">&#9670;&#160;</a></span>E_VTABLE_UNKNOWN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define E_VTABLE_UNKNOWN&#160;&#160;&#160;0xFF</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constant denoting that the VTable pointer is not valid. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gac47babdf383d8e134907594b7205796e" name="gac47babdf383d8e134907594b7205796e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac47babdf383d8e134907594b7205796e">&#9670;&#160;</a></span>RPC_Method_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* RPC_Method_t) (<a class="el" href="group__os__rpc.html#ga1c1678be361051059ce59465b10e1c39">RPC_Service_t</a> *service, unsigned arg0, unsigned arg1, unsigned arg2, unsigned arg3)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calling signature of a RPC call. </p>
<p>Any function that wants to implement a RPC call has to have this signature. If function won't have use for any of <code>arg0</code>, <code>arg1</code>, <code>arg2</code>, <code>arg3</code>, they can be omitted right-to-left. The argument <code>service</code> cannot be omitted and its position as the first argument has to be maintained. RPC calls are limited to use the general purpose registers only. Floating point registers cannot be used as it might not be possible to determine which registers were actually used to pass the arguments. This restricts the use of floating-point types to perform RPC calls. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">service</td><td>Address of RPC object which was used to perform this RPC call. Works like self` variable in Python. </td></tr>
    <tr><td class="paramname">arg0</td><td>optional argument to RPC call. Can only be of integral 32-bit large type </td></tr>
    <tr><td class="paramname">arg1</td><td>optional argument to RPC call. Can only be of integral 32-bit large type </td></tr>
    <tr><td class="paramname">arg2</td><td>optional argument to RPC call. Can only be of integral 32-bit large type </td></tr>
    <tr><td class="paramname">arg3</td><td>optional argument to RPC call. Can only be of integral 32-bit large type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1c1678be361051059ce59465b10e1c39" name="ga1c1678be361051059ce59465b10e1c39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c1678be361051059ce59465b10e1c39">&#9670;&#160;</a></span>RPC_Service_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structRPC__Service__t__.html">RPC_Service_t_</a> <a class="el" href="group__os__rpc.html#ga1c1678be361051059ce59465b10e1c39">RPC_Service_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gadcd71cb246a9a05989ca78eb79175239" name="gadcd71cb246a9a05989ca78eb79175239"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadcd71cb246a9a05989ca78eb79175239">&#9670;&#160;</a></span>VTable_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__os__rpc.html#gac47babdf383d8e134907594b7205796e">RPC_Method_t</a>* <a class="el" href="group__os__rpc.html#gadcd71cb246a9a05989ca78eb79175239">VTable_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type definition of VTable. </p>
<p>VTable is technically just an array of pointers to functions. To make things more user friendly, in real world cases, VTables are usually a structures whose members are pointers to functions. The memory layout of both cases is the same but structures allows for named members. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gab6a04c90d0385e2685fb5e494af298ff" name="gab6a04c90d0385e2685fb5e494af298ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab6a04c90d0385e2685fb5e494af298ff">&#9670;&#160;</a></span>get_vtable_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__api.html#ga36958e2082eecb09f367fa4aa3a9a84d">Process_t</a> get_vtable_process </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__os__rpc.html#gadcd71cb246a9a05989ca78eb79175239">VTable_t</a> *&#160;</td>
          <td class="paramname"><em>vtable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Identify process which owns the VTable. </p>
<p>This function will find the process which defined this vtable. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vtable</td><td>address of the vtable retrieved from the RPC object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>process ID of the owning process or <a class="el" href="group__os__rpc.html#gac23283a15be44b1f8451954379b2c723">E_VTABLE_UNKNOWN</a> if vtable address does not belong to any known process. </dd></dl>

</div>
</div>
<a id="ga9ee8f29f3009ad125af02a612603504f" name="ga9ee8f29f3009ad125af02a612603504f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ee8f29f3009ad125af02a612603504f">&#9670;&#160;</a></span>os_rpc_call()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int os_rpc_call </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>arg0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>arg2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>arg3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kernel implementation of rpc_call syscall. </p>
<p>This routine performs remote procedure call. It digs for 5th and 6th argument passed to <a class="el" href="group__arch__arm__rpc.html#ga241bd76bc39dd9597dd818fc530bec57">_rpc_call()</a> on thread stack. Retrieves address of called method from service VMT and synthesizes stack frame for jumping into this method. Arguments used to call <a class="el" href="group__arch__arm__rpc.html#ga241bd76bc39dd9597dd818fc530bec57">_rpc_call()</a> are passed to callee.</p>
<p>This syscall has to validate the RPC service and method IDs, determine the address of RPC method and owning process. Then it has to transfer the control to RPC method in a manner that:</p><ul>
<li>method called will be able to access the first four arguments given to the <a class="el" href="group__api__rpc.html#ga896b17abf6ce670f5000ac4a0852393f">rpc_call()</a> call.</li>
<li>when method returns, the <a class="el" href="group__arch__arch.html#ga2b0268c1c8ecd0d6e3194f0f52be350c">os_rpc_return()</a> is triggered and will transfer the control back</li>
<li>to the calling code and process. </li>
</ul>

</div>
</div>
<a id="ga2b0268c1c8ecd0d6e3194f0f52be350c" name="ga2b0268c1c8ecd0d6e3194f0f52be350c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b0268c1c8ecd0d6e3194f0f52be350c">&#9670;&#160;</a></span>os_rpc_return()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int os_rpc_return </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>arg0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>arg2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>arg3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kernel implementation of rpc_return syscall. </p>
<p>This routine unwinds stack frame used to call RPC method and passes return value from RPC to the caller.</p>
<p>This syscall has to return the control back to the code which called <a class="el" href="group__api__rpc.html#ga896b17abf6ce670f5000ac4a0852393f">rpc_call</a>. This has to be done in a way that the calling code will be able to access the return value of the RPC method. </p>

</div>
</div>
<a id="gae6cf8081b66bf611d61c09b161af5501" name="gae6cf8081b66bf611d61c09b161af5501"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae6cf8081b66bf611d61c09b161af5501">&#9670;&#160;</a></span>rpc_stack_pop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rpc_stack_pop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the last entry in the RPC stack. </p>
<p>Removes the most recently added entry from thread's stack of RPC call owning processes. Will do nothing if stack is already empty. </p><dl class="section return"><dt>Returns</dt><dd>new depth of the stack. Returns 0 if stack is empty. </dd></dl>

</div>
</div>
<a id="ga26f43d83332c3aca17beb91973e59156" name="ga26f43d83332c3aca17beb91973e59156"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga26f43d83332c3aca17beb91973e59156">&#9670;&#160;</a></span>rpc_stack_push()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rpc_stack_push </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__api.html#ga36958e2082eecb09f367fa4aa3a9a84d">Process_t</a>&#160;</td>
          <td class="paramname"><em>process_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add new process ID to the stack of RPC calls. </p>
<p>Registers new process ID in thread's stack of RPC call owning processes. This stack records which process is "owning" this thread while RPC call is in effect. While RPC call can technically perform another RPC call, this is a stack rather than plain field. New member is always added on top of the stack unless stack is full. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">process_id</td><td>ID of the process owning the RPC method </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if process was added, false if stack is already full </dd></dl>

</div>
</div>
<a id="ga34f4075561574cff1c35a7b4913f2105" name="ga34f4075561574cff1c35a7b4913f2105"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga34f4075561574cff1c35a7b4913f2105">&#9670;&#160;</a></span>rpc_stack_top()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__api.html#ga36958e2082eecb09f367fa4aa3a9a84d">Process_t</a> rpc_stack_top </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the topmost process ID in thread's RPC call stack. </p>
<p>Returns the process ID of the most recently added entry in thread's stack of RPC call owning processes. </p><dl class="section return"><dt>Returns</dt><dd>Most recently added process_ID or <a class="el" href="group__os__rpc.html#gac23283a15be44b1f8451954379b2c723">E_VTABLE_UNKNOWN</a> if RPC call stack is empty. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.7-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</div>
</body>
</html>
