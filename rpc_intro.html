<!-- HTML header for doxygen 1.9.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>C Microkernel Realtime eXecutive: Remote Procedure Calls</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="all">
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">C Microkernel Realtime eXecutive
   </div>
   <div id="projectbrief">Realtime Operating System for Cortex-M based microcontrollers</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('rpc_intro.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Remote Procedure Calls</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Remote procedure calls are one of few existing ways of communicating between processes. While threads can use mutexes (as all threads of same process have access to same memory and therefore to same mutexes), threads of different processes can't all access the same memory regions all the time.</p>
<p>Remote procedure calling has, as pretty much any IPC mechanism two ends. The callee end and the caller end. Callee end is the end which ends up being called as a result of RPC and we will call it "server" in further text. Caller is the one, who will perform the call, once it decides it is right time to do so. We will call it "client" for short.</p>
<h2><a class="anchor" id="autotoc_md35"></a>
High level design of RPC mechanism</h2>
<p>From high level perspective, RPC interface works in a way similar to C++ objects. Server process can declare one or more services, which are composed of methods. Methods are callable via the instance of the service.</p>
<div class="dotgraph">
<img src="dot_inline_dotgraph_3.png" alt="dot_inline_dotgraph_3.png" border="0" usemap="#dot_inline_dotgraph_3.map"/>
<div class="caption">
Hierarchy of RPC components</div>
</div>
<p>From the server perspective, the service instance is a fully defined structure, which holds service data and contains pointer to the list of callable service methods.</p>
<p>From the caller perspective, the service instance is an opaque pointer. This pointer, once obtained, can be used to call service methods. Internally, the object pointed to contains link to service method table. If caller uses this pointer to call service method, this call gets resolved on compile time. If method with requested name does not exist in target service, the compilation fails.</p>
<p>Despite the fact, that the called method is resolved during the compile time, the call itself is performed based on the service status during the runtime. Compile time resolution makes sure that target method actually exists within referenced service and composes kernel call to perform RPC call.</p>
<p>Later, during the runtime, kernel resolves service method address and passes control to the provided address. At no time, the calling process has access to service object, despite it's ability to call service methods. Runtime resolution is done by the kernel.</p>
<h2><a class="anchor" id="autotoc_md37"></a>
RPC interface</h2>
<p>RPC interface is a structure, which lists pointer-to-function kind of members. This is a typical way of writing "C classes". There are no special requirements for internal organization of this structure except of typical best practices in writing reusable interfaces.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cmrx/rpc/interface.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>RPC_interface {</div>
<div class="line">    void (*method_1)(<a class="code hl_define" href="group__api__rpc.html#gac79f9e6f9c7223d603a5ac7365617ea7">INSTANCE</a>(<span class="keyword">this</span>), <span class="keywordtype">int</span> arg1);</div>
<div class="line">    int (*method_2)(<a class="code hl_define" href="group__api__rpc.html#gac79f9e6f9c7223d603a5ac7365617ea7">INSTANCE</a>(<span class="keyword">this</span>), <span class="keywordtype">int</span> arg1, <span class="keywordtype">int</span> arg2);</div>
<div class="line">    <span class="keywordtype">void</span> * (*method_3)(<a class="code hl_define" href="group__api__rpc.html#gac79f9e6f9c7223d603a5ac7365617ea7">INSTANCE</a>(<span class="keyword">this</span>) <span class="comment">/* no arguments */</span>);</div>
<div class="line">};</div>
<div class="ttc" id="agroup__api__rpc_html_gac79f9e6f9c7223d603a5ac7365617ea7"><div class="ttname"><a href="group__api__rpc.html#gac79f9e6f9c7223d603a5ac7365617ea7">INSTANCE</a></div><div class="ttdeci">#define INSTANCE(a)</div><div class="ttdoc">Mark function argument as reference to current service instance.</div><div class="ttdef"><b>Definition</b> implementation.h:115</div></div>
</div><!-- fragment --><p>There are limitations given by RPC mechanism in CMRX though. Any method of RPC interface has to have 1 up to 5 arguments. First arguments <b>must</b> be pointer to instance. This semantics is same as used in Python methods. Remaining four arguments can be of any scalar type. Method can return any scalar type, but does not need to return anything.</p>
<h2><a class="anchor" id="autotoc_md40"></a>
RPC service</h2>
<p>RPC service holds the data, RPC service provides access to. It is plain C structure with only one requirement. First member of this struct <b>must</b> be a pointer to the RPC service, which provides access to this object and this member <b>must</b> be called <code>vtable</code>. Amount, types, structure and order of remaining items is completely up to application developer. Even removal or reordering of items within structure won't compromise binary compatibility, as long as your service can cope with it.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>RPC_service {</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">struct </span>RPC_interface vtable;</div>
<div class="line">    <span class="keywordtype">long</span> <span class="keywordtype">long</span> service_data;</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md42"></a>
Becoming a RPC server</h2>
<p>In order for some application to define a RPC server, it has to do quite a few things:</p>
<h2><a class="anchor" id="autotoc_md43"></a>
Declare interfaces</h2>
<p>Very first step is to define the interface. Interface is a structure visible both to the server and the client, which defines what actions some type of service supports. Interface is purely procedural and does not support publishing of data members. Interface has a form of structure containing pointer-to-function members. Interfaces shall be as abstract as possible, creating contracts between the caller and the callee rather than describe manipulation methods specific to one single interface. This facilitates interface reuse. If your service has possible actions similar to some other service, then both services shall implement the same interface. If they do then these services are interchangeable. Caller can call an instance of both without actually knowing what specific service it is calling or that they are in fact different.</p>
<p>This step can be skipped if there is suitable interface available somewhere in your project. You can reuse it rather than defining your own interface.</p>
<h2><a class="anchor" id="autotoc_md45"></a>
Declare services</h2>
<p>After interfaces were defined (or adopted), the structure of the service itself has to be provided. This is typically a structure, which holds all the state of the service. This structure must contain a link to the interface, this service implements.</p>
<p>In CMRX, the internals of the structure are never accessible outside the owning process. So in practice, it is possible to provide two declarations of the service: One, fully specified with all the data members. This one is used internally while writing the service implementation. Another, containing only the reference to interface implemented may be provided for callers.</p>
<p>Above is not a must, even if caller knows the internal structure of the interface, it is not possible to access it. Not even in read-only manner.</p>
<h2><a class="anchor" id="autotoc_md46"></a>
Define service implementation</h2>
<p>Next, it is necessary to provide implementation of all functions declared in the interface this service implements. Once these functions are implemented, they can be put together into interface implementation table. This is an instance of interface, where function pointers point to actual functions just created.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cmrx/rpc/implementation.h&gt;</span></div>
<div class="line"><a class="code hl_define" href="group__api__rpc.html#ga3467c0dc3f1f95bb00289609f2ce35f8">IMPLEMENTATION_OF</a>(<span class="keyword">struct</span> RPC_service, <span class="keyword">struct</span> RPC_interface);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> service_method_1(<a class="code hl_define" href="group__api__rpc.html#gac79f9e6f9c7223d603a5ac7365617ea7">INSTANCE</a>(<span class="keyword">this</span>), <span class="keywordtype">int</span> arg1)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">/* ..... */</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span> service_method_2(<a class="code hl_define" href="group__api__rpc.html#gac79f9e6f9c7223d603a5ac7365617ea7">INSTANCE</a>(<span class="keyword">this</span>), <span class="keywordtype">int</span> arg1, <span class="keywordtype">int</span> arg2)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">/* ..... */</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> * service_method_3(<a class="code hl_define" href="group__api__rpc.html#gac79f9e6f9c7223d603a5ac7365617ea7">INSTANCE</a>(<span class="keyword">this</span>))</div>
<div class="line">{</div>
<div class="line">    <span class="comment">/* ..... */</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="group__api__init.html#gaa4a137442c139400b647ac62b40ea51a">VTABLE</a> <span class="keyword">struct </span>RPC_interface service_vtable = {</div>
<div class="line">    service_method_1,</div>
<div class="line">    service_method_2,</div>
<div class="line">    service_method_3</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>RPC_service service = {</div>
<div class="line">    &amp;service_vtable,</div>
<div class="line">    0x42</div>
<div class="line">};</div>
<div class="ttc" id="agroup__api__init_html_gaa4a137442c139400b647ac62b40ea51a"><div class="ttname"><a href="group__api__init.html#gaa4a137442c139400b647ac62b40ea51a">VTABLE</a></div><div class="ttdeci">#define VTABLE</div><div class="ttdef"><b>Definition</b> application.h:31</div></div>
<div class="ttc" id="agroup__api__rpc_html_ga3467c0dc3f1f95bb00289609f2ce35f8"><div class="ttname"><a href="group__api__rpc.html#ga3467c0dc3f1f95bb00289609f2ce35f8">IMPLEMENTATION_OF</a></div><div class="ttdeci">#define IMPLEMENTATION_OF(service, interface)</div><div class="ttdoc">Extended version of IMPLEMENTATION macro.</div><div class="ttdef"><b>Definition</b> implementation.h:103</div></div>
</div><!-- fragment --><p>If any interface provides some function, then it is mandatory to implement it. No pointer in interface can point to NULL. Doing so will crash any caller which attempts to call such interface method.</p>
<p>Instances of interfaces have to be marked by special keyword <a class="el" href="group__api__init.html#gaa4a137442c139400b647ac62b40ea51a">VTABLE</a>. This keyword serves the purpose of putting such variable into VTABLE "region" of the process. Only those interface implementations residing in VTABLE regions can be called. Net effects of this limitation are two:</p><ol type="1">
<li>Only RPC services, which were intentionally provided as such, can be used to perform legitimate RPC call. No random data put together which resemble pointer-to-function array can be used as a RPC service.</li>
<li>Presence of VTABLE address in some particular process' VTABLE region established relationship between RPC service and owning process. This is also important from memory protection perspective, as it allows kernel to determine, how to set up memory protection during the RPC call.</li>
</ol>
<h2><a class="anchor" id="autotoc_md48"></a>
Calling RPC service</h2>
<p>Once RPC service has been established having its own implementation it is possible to perform calls of this service. Service instance lives in the address space of the process, which instantiated it. It is not possible to place the service instance into some globally-accessible place as no such space exists. It is not even needed. All that any potential caller needs is the address of the service. Call of this service can then be performed using the following code:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> retval = <a class="code hl_define" href="group__api__rpc.html#ga896b17abf6ce670f5000ac4a0852393f">rpc_call</a>(service_ptr, method_2, 0x42, 0xF00F);</div>
<div class="ttc" id="agroup__api__rpc_html_ga896b17abf6ce670f5000ac4a0852393f"><div class="ttname"><a href="group__api__rpc.html#ga896b17abf6ce670f5000ac4a0852393f">rpc_call</a></div><div class="ttdeci">#define rpc_call(service_instance, method_name,...)</div><div class="ttdoc">User-visible way to perform remote procedure call.</div><div class="ttdef"><b>Definition</b> rpc.h:122</div></div>
</div><!-- fragment --><p>This call will perform the call of method_2 from within service using CMRX RPC mechanism.</p>
<h2><a class="anchor" id="autotoc_md49"></a>
Advantages of RPC mechanism</h2>
<p>Why mechanism so complicated?</p>
<p>Despite looking complicated, this mechanism has a few advantages over directly calling functions, or calling functions via pointer-to-function table indirection. If we first consider the simplest case of calling specific service functions via their names directly, such as:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> retval = service_method_2(service_ptr, 0x42, 0xF00F);</div>
</div><!-- fragment --><p>Then there is an obvious difference, that in the latter case, you are explicitly stating the method to call. While using the RPC mechanism, you are only stating its name. So the service is able to provide whatever specific function that implements the requested method for this specific kind of service. Calling client and called server are tightly bound to perform one specific action.</p>
<p>Another way of calling service methods in a polymorphic way is to use "object oriented C" approach and call the method like:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> retval = service_ptr-&gt;vtable-&gt;method_2(service_ptr, 0x42, 0xF00F);</div>
</div><!-- fragment --><p>This approach is much closer to what RPC call actually does with a few little, yet important differences. Even if it looks like the actual function executed when <code>method_2</code> is called can be changed, it isn't absolutely true. There is still rather high degree of binding between the interface and the service here. The function, whose address is used to initialize the vtable structure must match the type and count of arguments in the vtable type declaration. This will force you to use method with the following prototype:</p>
<div class="fragment"><div class="line">int (*method_2_t)(RPC_service * <span class="keyword">this</span>, <span class="keywordtype">int</span> arg1, <span class="keywordtype">int</span> arg2);</div>
</div><!-- fragment --><p>This works as long as you have one service and one interface. There is direct relationship between RPC_interface structure whose members type their first argument as <code>RPC_service *</code>. If you attempt to create an interface usable with multiple services, you will face type incompatibility problems. Either you'll have to typecast functions during the initialization of RPC_interface instance, or use some generic type for <code>this</code>, such as <code>void * this</code>. Both will clutter the code with typecasts and will throw part of type safety as typecasts will be explicit and can contain typos or other mistakes.</p>
<p>Another problem of both approaches is, that the function which ends up being called one way or another must reside in the same process as the caller. You can't call function from within another process as it will crash in the moment it tries to access it's own process' memory.</p>
<p>RPC call mechanism deals with both problems. Syntactic sugar around the macro <a class="el" href="group__api__rpc.html#gac79f9e6f9c7223d603a5ac7365617ea7">INSTANCE()</a> causes that whenever an interface is declared, its <code>this</code> pointer is not typed. It effectively behaves as <code>void * this</code>. On the other side, whenever you provide an implementation of the interface, you have to provide a service - interface pair. When you do this, the check, if the intended service actually provides intended interface will happen. This way, typos are avoided. Attempt to implement an interface for service it isn't providing it will cause build error. Another effect is that use of macro <a class="el" href="group__api__rpc.html#gac79f9e6f9c7223d603a5ac7365617ea7" title="Mark function argument as reference to current service instance.">INSTANCE()</a> during the implementation of the interface will use the correct type expected by this specific implementation.</p>
<p>From the client's perspective, the actual type of service data structure is not important. Client handles structure instance as an opaque pointer during runtime. It never accesses it as it resides in other process' memory. All the preparatory work to implement the RPC call is done during the compile time. Here, the type checking is done, so that the type and amount of arguments to the call is checked. Compilation will fail if there is a mismatch. Compilation will also fail if there is an attempt to call non-existent RPC method.</p>
<p>Then, during the runtime, when RPC call is performed, CMRX kernel will make necessary adjustments of the runtime environment to allow the called method to access the memory region of owning process. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.7-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</div>
</body>
</html>
