<!-- HTML header for doxygen 1.9.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>C Microkernel Realtime eXecutive: Queue library</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="all">
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">C Microkernel Realtime eXecutive
   </div>
   <div id="projectbrief">Realtime Operating System for Cortex-M based microcontrollers</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__aux__queue.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Queue library<div class="ingroups"><a class="el" href="group__libs.html">Libraries</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>This is auxiliary implementation of queue.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structQueue.html">Queue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic queue structure.  <a href="structQueue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBasicQueue.html">BasicQueue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structQueue.html" title="Generic queue structure.">Queue</a> with 256 bytes of storage preallocated.  <a href="structBasicQueue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga055729a37bf543876e2ce9d57b95ab7b" id="r_ga055729a37bf543876e2ce9d57b95ab7b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__aux__queue.html#ga055729a37bf543876e2ce9d57b95ab7b">QUEUE_LENGTH</a>&#160;&#160;&#160;256</td></tr>
<tr class="separator:ga055729a37bf543876e2ce9d57b95ab7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga185265efed6cb953257ad32f811cfe23" id="r_ga185265efed6cb953257ad32f811cfe23"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__aux__queue.html#ga185265efed6cb953257ad32f811cfe23">STATIC_QUEUE</a>(name,  size)</td></tr>
<tr class="memdesc:ga185265efed6cb953257ad32f811cfe23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create queue with custom storage allocation size.  <br /></td></tr>
<tr class="separator:ga185265efed6cb953257ad32f811cfe23"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaa7d1e0d4ea7e93ad6af453ebabd644d2" id="r_gaa7d1e0d4ea7e93ad6af453ebabd644d2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__aux__queue.html#gaa7d1e0d4ea7e93ad6af453ebabd644d2">queue_init</a> (struct <a class="el" href="structQueue.html">Queue</a> *queue, uint8_t depth, uint8_t item_size)</td></tr>
<tr class="memdesc:gaa7d1e0d4ea7e93ad6af453ebabd644d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize queue structure.  <br /></td></tr>
<tr class="separator:gaa7d1e0d4ea7e93ad6af453ebabd644d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7fe4467c0404b3ff715b0c359d0188f" id="r_gab7fe4467c0404b3ff715b0c359d0188f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__aux__queue.html#gab7fe4467c0404b3ff715b0c359d0188f">queue_send</a> (struct <a class="el" href="structQueue.html">Queue</a> *queue, const void *data)</td></tr>
<tr class="memdesc:gab7fe4467c0404b3ff715b0c359d0188f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send data via the queue.  <br /></td></tr>
<tr class="separator:gab7fe4467c0404b3ff715b0c359d0188f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b39109a0cec8cb801afeb993057e171" id="r_ga0b39109a0cec8cb801afeb993057e171"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__aux__queue.html#ga0b39109a0cec8cb801afeb993057e171">queue_send_silent</a> (struct <a class="el" href="structQueue.html">Queue</a> *queue, const void *data)</td></tr>
<tr class="memdesc:ga0b39109a0cec8cb801afeb993057e171"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills queue without notifying receivers.  <br /></td></tr>
<tr class="separator:ga0b39109a0cec8cb801afeb993057e171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89f16741916b51f47ff0f5e154613fc8" id="r_ga89f16741916b51f47ff0f5e154613fc8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__aux__queue.html#ga89f16741916b51f47ff0f5e154613fc8">queue_receive_timeout</a> (struct <a class="el" href="structQueue.html">Queue</a> *queue, void *data, uint32_t timeout_us)</td></tr>
<tr class="memdesc:ga89f16741916b51f47ff0f5e154613fc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive data from queue with timeout.  <br /></td></tr>
<tr class="separator:ga89f16741916b51f47ff0f5e154613fc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a42b170d904edd0c6d9ec37a616a6cf" id="r_ga6a42b170d904edd0c6d9ec37a616a6cf"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__aux__queue.html#ga6a42b170d904edd0c6d9ec37a616a6cf">queue_receive</a> (struct <a class="el" href="structQueue.html">Queue</a> *queue, void *data)</td></tr>
<tr class="memdesc:ga6a42b170d904edd0c6d9ec37a616a6cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive data from queue.  <br /></td></tr>
<tr class="separator:ga6a42b170d904edd0c6d9ec37a616a6cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4eb65aa97addc979fe4486b7456682d9" id="r_ga4eb65aa97addc979fe4486b7456682d9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__aux__queue.html#ga4eb65aa97addc979fe4486b7456682d9">queue_empty</a> (struct <a class="el" href="structQueue.html">Queue</a> *queue)</td></tr>
<tr class="memdesc:ga4eb65aa97addc979fe4486b7456682d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns queue status.  <br /></td></tr>
<tr class="separator:ga4eb65aa97addc979fe4486b7456682d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2bde6f72ff0cc4a047ee99454ac3dd6" id="r_gaf2bde6f72ff0cc4a047ee99454ac3dd6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__aux__queue.html#gaf2bde6f72ff0cc4a047ee99454ac3dd6">queue_full</a> (struct <a class="el" href="structQueue.html">Queue</a> *queue)</td></tr>
<tr class="memdesc:gaf2bde6f72ff0cc4a047ee99454ac3dd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell if queue is already full.  <br /></td></tr>
<tr class="separator:gaf2bde6f72ff0cc4a047ee99454ac3dd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>This is auxiliary implementation of queue. </p>
<p>CMRX does not offer queues as an inherent service provided by the kernel as this does not fit the microkernel nature of CMRX RTOS.</p>
<p>CMRX natively supports lower communication and synchronization primitives than queues.</p>
<p>This implementation offers single producer-single consumer safe implementation of queue that is usable even from interrupt context.</p>
<p>This library will find uses if you need to implement queue between threads of single process and/or you need to push data into queue from ISR handler.</p>
<p>If you need a queue that works across processes then see aux_queue_server which wraps this library into RPC interface and thus is usable globally. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga055729a37bf543876e2ce9d57b95ab7b" name="ga055729a37bf543876e2ce9d57b95ab7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga055729a37bf543876e2ce9d57b95ab7b">&#9670;&#160;</a></span>QUEUE_LENGTH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QUEUE_LENGTH&#160;&#160;&#160;256</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga185265efed6cb953257ad32f811cfe23" name="ga185265efed6cb953257ad32f811cfe23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga185265efed6cb953257ad32f811cfe23">&#9670;&#160;</a></span>STATIC_QUEUE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define STATIC_QUEUE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">size&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keyword">struct </span>{\</div>
<div class="line">    <span class="keyword">union </span>{\</div>
<div class="line">        <span class="keyword">struct </span><a class="code hl_struct" href="structQueue.html">Queue</a> q;\</div>
<div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> buffer[<span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code hl_struct" href="structQueue.html">Queue</a>) + size];\</div>
<div class="line">    };\</div>
<div class="line">} name;</div>
<div class="ttc" id="astructQueue_html"><div class="ttname"><a href="structQueue.html">Queue</a></div><div class="ttdoc">Generic queue structure.</div><div class="ttdef"><b>Definition</b> queue.h:36</div></div>
</div><!-- fragment -->
<p>Create queue with custom storage allocation size. </p>
<p>This is a helper macro that defines queue with developer-specified size of the queue data storage. Suitable for cases where fixed allocation size of 256 bytes of <a class="el" href="structBasicQueue.html">BasicQueue</a> is either too much or too little. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>resulting name of queue variable </td></tr>
    <tr><td class="paramname">size</td><td>size of the buffer in bytes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga4eb65aa97addc979fe4486b7456682d9" name="ga4eb65aa97addc979fe4486b7456682d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4eb65aa97addc979fe4486b7456682d9">&#9670;&#160;</a></span>queue_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool queue_empty </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structQueue.html">Queue</a> *&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns queue status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>pointer to queue queried </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if queue is empty, false otherwise </dd></dl>

</div>
</div>
<a id="gaf2bde6f72ff0cc4a047ee99454ac3dd6" name="gaf2bde6f72ff0cc4a047ee99454ac3dd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf2bde6f72ff0cc4a047ee99454ac3dd6">&#9670;&#160;</a></span>queue_full()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool queue_full </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structQueue.html">Queue</a> *&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tell if queue is already full. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>pointer to queue queried </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if queue is full false otherwise </dd></dl>

</div>
</div>
<a id="gaa7d1e0d4ea7e93ad6af453ebabd644d2" name="gaa7d1e0d4ea7e93ad6af453ebabd644d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa7d1e0d4ea7e93ad6af453ebabd644d2">&#9670;&#160;</a></span>queue_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool queue_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structQueue.html">Queue</a> *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>item_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize queue structure. </p>
<p>This call will initialize queue structure. It does not examine previous state of the structure, thus any previous existing state is erased.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>pointer to queue being initialized </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">depth</td><td>amount of entries queue should be able to store </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">item_size</td><td>size of each item in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if queue was initialized. Returns false if queue storage capacity is not sufficient for requested depth and item size </dd></dl>

</div>
</div>
<a id="ga6a42b170d904edd0c6d9ec37a616a6cf" name="ga6a42b170d904edd0c6d9ec37a616a6cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a42b170d904edd0c6d9ec37a616a6cf">&#9670;&#160;</a></span>queue_receive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool queue_receive </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structQueue.html">Queue</a> *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Receive data from queue. </p>
<p>This will copy the oldest data out of the queue. If queue is empty then this call will block until queue is filled with at least one entry of data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>pointer to queue data is retrieved from </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>pointer to place where data will be written </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true. Returns false in case spurious interrupt occurred and queue is still empty. </dd></dl>

</div>
</div>
<a id="ga89f16741916b51f47ff0f5e154613fc8" name="ga89f16741916b51f47ff0f5e154613fc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga89f16741916b51f47ff0f5e154613fc8">&#9670;&#160;</a></span>queue_receive_timeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool queue_receive_timeout </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structQueue.html">Queue</a> *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout_us</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive data from queue with timeout. </p>
<p>This will copy the oldest data out of the queue. If queue is empty then this call will block until queue is filled with data or until specified amount of time passed with no new data in the queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>pointer to queue data is retrieved from </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>pointer to place where data will be written </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout_us</td><td>amount of time to wait for the data. If 0 is passed as timeout, then the function will wait indefinitely. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if data were read from queue. Returns false in case specified amount of time elapsed and no new data is available. </dd></dl>

</div>
</div>
<a id="gab7fe4467c0404b3ff715b0c359d0188f" name="gab7fe4467c0404b3ff715b0c359d0188f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7fe4467c0404b3ff715b0c359d0188f">&#9670;&#160;</a></span>queue_send()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool queue_send </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structQueue.html">Queue</a> *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send data via the queue. </p>
<p>This will copy data into queue. <a class="el" href="structQueue.html" title="Generic queue structure.">Queue</a> must be initialized before this call is made. The size of data is determined based on value of <code>item_size</code> used during queue initialization.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>pointer to queue data is being sent into </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>pointer to data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if data was copied into queue and false if queue is already full </dd></dl>

</div>
</div>
<a id="ga0b39109a0cec8cb801afeb993057e171" name="ga0b39109a0cec8cb801afeb993057e171"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b39109a0cec8cb801afeb993057e171">&#9670;&#160;</a></span>queue_send_silent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool queue_send_silent </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structQueue.html">Queue</a> *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills queue without notifying receivers. </p>
<p>This method performs the same action as <a class="el" href="group__aux__queue.html#gab7fe4467c0404b3ff715b0c359d0188f">queue_send()</a> without actually performing notification of clients waiting for queue data to be available. This function may be useful e.g. in the interrupt context where calling <a class="el" href="group__api__notify.html#ga41864194fe48bd76519bcb27efcfb697">notify_object()</a> is not possible. </p><dl class="section warning"><dt>Warning</dt><dd>It is caller responsibility to perform suitable version of notification on the queue object, otherwise any potential receivers which are waiting for the data to arrive will keep waiting. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">queue</td><td>pointer to queue data is being sent into </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>pointer to data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if data was copied into queue and false if queue is already full </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.7-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</div>
</body>
</html>
