<!-- HTML header for doxygen 1.9.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>C Microkernel Realtime eXecutive: HOWTO: Integrating CMRX into CubeMX project</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="all">
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">C Microkernel Realtime eXecutive
   </div>
   <div id="projectbrief">Realtime Operating System for Cortex-M based microcontrollers</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('getting_started_cubemx.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">HOWTO: Integrating CMRX into CubeMX project</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Following is a step-by-step how to guide on creating a blinky project using CMRX RTOS. It will cover all steps and lists all tools needed to complete the integration. This guide assumes previous hands-on experience with creating embedded firmware, including the process of flashing and debugging. Basic understanding of CMake is assumed.</p>
<p>As an example, this howto will demonstrate the process of integrating CMRX into project generated by ST Microelectronics CubeMX tool. CMRX is flexible and supports virtually all microcontrollers with CMSIS headers available in their SDK/HAL. Thus this howto will avoid using vendor-specific build tools / IDEs to make the guide as portable as possible.</p>
<p>This example will demonstrate creation of basic blinky example using SysTick timer as the kernel timing provider.</p>
<h1><a class="anchor" id="autotoc_md6"></a>
Prerequisites</h1>
<p>In order to generate and build the project, following tools are required: </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Name   </th><th class="markdownTableHeadNone">Min. Supported Version   </th><th class="markdownTableHeadNone">Note    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">CMake   </td><td class="markdownTableBodyNone">3.22.0   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Python   </td><td class="markdownTableBodyNone">3.0   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">ARM GCC toolchain   </td><td class="markdownTableBodyNone">(as per CubeMX requirements)   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Native GCC toolchain   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">needed for unit test build, optional    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">GNU Make / Ninja   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Git   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td></tr>
</table>
<p>All the above tools need to be installed and available in execution path otherwise various parts of the configure and/or build process may fail. Note that if these tools are installed via default distribution mechanisms, they are usually available in execution path. If you install them manually, you may have add them to path as well.</p>
<p>Following is the list of additional tools required only by this guide. They are project / MCU specific or can be replaced by tools of your choice (e.g. IDE of your choice).</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Name   </th><th class="markdownTableHeadNone">Min. Supported Version   </th><th class="markdownTableHeadNone">Note    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">CubeMX   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">project specific    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">OpenOCD   </td><td class="markdownTableBodyNone">0.12.0   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">GDB   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">must be a multiarch build supporting AArch32   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md11"></a>
Creating project skeleton with CubeMX</h1>
<p>Unlike other embedded real-time operating systems, CMRX does not ship its own SDK or HALs. It is designed to embed into SDK supplied by the MCU manufacturer or into any other environment as seamlessly as possible.</p>
<p>So the actual project will be created by the CubeMX tool.</p>
<p>Start the CubeMX, at home screen select "New project" and then "Access to MCU selector". This allows you to select the MCU you are using. Any MCU containing core of Cortex-M0+, Cortex M3, Cortex-M4, Cortex-M7 and Cortex-M33 should be supported. In this example we will select the STM32H753ZIT6 found in NUCLEO-H753ZI development kit.</p>
<p>Once you found the desired MCU, click "Start project" button. This will move you into project main screen. Now you can save the project. By default, CubeMX will name the project after the directory where you save it. This guide will assume that you saved the project into directory <code>$HOME/projects/cmrx-cubemx-example</code>.</p>
<p>If CubeMX asks you if you want to configure MPU (Memory Protection Unit) of your MPU, then answer no. CMRX manages MPU on its own. Any settings configured by CubeMX will be overwritten.</p>
<h1><a class="anchor" id="autotoc_md13"></a>
Basic CubeMX project settings</h1>
<p>CMRX is based on the CMake buildsystem. CubeMX has built in support for generating CMake-based projects. Open <code>Project Manager</code> and change <code>Toolchain / IDE</code> to <code>CMake</code>.</p>
<p>Next, change the stack size. The stack size configured by the CubeMX will be used as kernel and interrupt service routines stack. Stack as large as 4kB should be sufficient even for larger libraries, such as TinyUSB.</p>
<div class="image">
<img src="cubemx-project-settings.png" alt=""/>
<div class="caption">
Project Settings Changes</div></div>
    <h1><a class="anchor" id="autotoc_md15"></a>
Configuring the core</h1>
<p>This step is CubeMX-specific. CMRX is flexible regarding the source of the kernel timing information. This simple example will use the built-in SysTick-based timing provider. In order to be able to use it, SysTick must not be used by the HAL itself. As this is the default, we need to reconfigure HAL to use different clock source for its routines. You can select any timer not utilized by your application. In this case <code>TIM1</code> is selected.</p>
<div class="image">
<img src="cubemx-timer-config.png" alt=""/>
<div class="caption">
System Timer Configuration</div></div>
    <h1><a class="anchor" id="autotoc_md16"></a>
Configuring GPIOs</h1>
<p>As the blinky application has to blink a LED, we have to configure some GPIO to be output so we can attach the LED to it. Targeting the Nucleo H753 board we can configure three user LEDs already hooked up to the CPU. The GPIO configuration in CubeMX may look like this:</p>
<div class="image">
<img src="cubemx-gpio-config.png" alt=""/>
<div class="caption">
GPIO Configuration</div></div>
    <p>This configuration will provide three named pins: <code>LED_GREEN_Pin</code>, <code>LED_YELLOW_Pin</code> and <code>LED_RED_Pin</code>.</p>
<h1><a class="anchor" id="autotoc_md18"></a>
Generating project and getting CMRX source</h1>
<p>Now you are ready to generate the project skeleton. Hit the "Generate Core" button in upper-right corner. This will generate the code into the directory where you saved your project.</p>
<div class="image">
<img src="cubemx-generated-project.png" alt=""/>
<div class="caption">
Generated Project</div></div>
    <p>At this stage you can use CMake to generate the project and build it:</p>
<div class="fragment"><div class="line">cd $HOME/projects/cmrx-cubemx-example</div>
<div class="line">cmake -G Ninja -B build</div>
<div class="line">cmake --build build</div>
</div><!-- fragment --><p>Great! You have your project skeleton. Now it is finally time to start versioning your project and integrate CMRX. So, lets initialize the Git repository and retrieve CMRX source code:</p>
<div class="fragment"><div class="line">git init</div>
<div class="line">git submodule add https://github.com/ventZl/cmrx.git</div>
<div class="line">git submodule update --init --recursive</div>
</div><!-- fragment --><p>This will create <code>cmrx</code> subdirectory that contains the CMRX source tree and associated tools. As part of this process the <code>ctest</code> source tree is initialized as a CMRX submodule. This is used to perform unit testing.</p>
<h1><a class="anchor" id="autotoc_md20"></a>
Integrating CMRX into CubeMX project</h1>
<p>In following steps, we will make sure that CMRX is built along the rest of the project and that the operating system can actually use the HAL. Bulk of the CMRX is built as a static library that can be linked to your project. So lets add it to the build.</p>
<p>Open the <code>CMakeLists.txt</code> generated by the CubeMX and make following modifications:</p>
<h2><a class="anchor" id="autotoc_md21"></a>
1. Add CMake modules provided by CMRX into CMake module path</h2>
<p>At the top of <code>CMakeLists.txt</code> add the following line:</p>
<div class="fragment"><div class="line">list(APPEND CMAKE_MODULE_PATH ${CMAKE_CURRENT_SOURCE_DIR}/cmrx/cmake)</div>
</div><!-- fragment --><p>It will allow you to include CMRX-specific CMake modules without explicitly stating path.</p>
<h2><a class="anchor" id="autotoc_md22"></a>
2. Configure CubeMX integration</h2>
<p>If you tried to configure the project at this time, you'd get an error saying: "Target 
architecture not configured". This is because so far we did not tell the CMRX what machine it is bewing built for.</p>
<p>Instead of providing microcontroller-specific ports, CMRX relies on generic architecture support. For ARM Cortex-M this is possible due to the CMSIS device headers available for virtually all microcontrollers. CMRX can run on any microcontroller whose SDK/HAL provides these headers. CubeMX HAL does provide them.</p>
<p>To make the job easier, the ARM architecture support package provides <code>FindCMSIS</code> CMake module. This module will find necessary CMSIS components and configure the kernel to use them. To be able to do so efficiently, you need to provide it with some basic configuration details.</p>
<p>Lets add <code>FindCMSIS</code> into the <code>CMakeLists.txt</code>. Add the following block after the previous one:</p>
<div class="fragment"><div class="line">set(CMSIS_ROOT ${CMAKE_SOURCE_DIR}/Drivers/CMSIS)</div>
<div class="line">set(DEVICE stm32h753xx)</div>
<div class="line">set(CMSIS_LINKER_FILE ${CMAKE_SOURCE_DIR}/stm32h753zitx_flash.ld)</div>
<div class="line">set(SYSTEM_INCLUDE_FILENAME system_stm32h7xx.h)</div>
<div class="line">include(FindCMSIS)</div>
</div><!-- fragment --><p>This block configures a few variables and then includes the <code>FindCMSIS</code> module. These variables contain the following information:</p>
<ul>
<li><code>CMSIS_ROOT</code> - path to where CMSIS headers are stored within HAL/SDK sources. This depends on the HAL/MCU used. This variable is mandatory.</li>
<li><code>DEVICE</code> - the name of microcontroller used. CMSIS headers require this variable to be set in order to provide correct definitions. Use the device name as supported by your HAL/SDK. This variable is mandatory.</li>
<li><code>CMSIS_LINKER_FILE</code> - path to the linker file used by the project. The actual path to the linker file may vary. Certain SDKs/HALs provide fixed linker scripts that are shipped with the SDK, some (such as CubeMX) will generate linker script based on project configuration. This variable is mandatory and must point to existing file.</li>
<li><code>SYSTEM_INCLUDE_FILENAME</code> - this variable is optional. It may be needed in case that the CMSIS system include file does not match your DEVICE name. Normally, the system include filename should be system_&lt;$DEVICE&gt;.h but that's often not the case. If your HAL uses different naming pattern (CubeMX often does) then you have to provide the name of this header.</li>
</ul>
<p>Once all the variables are set, we can include FindCMSIS that will configure the ARM architecture support to use the CubeMX HAL.</p>
<h2><a class="anchor" id="autotoc_md25"></a>
3. Configure the CMRX kernel to use CubeMX</h2>
<p>The last step needed is to configure the kernel to actually use the configuration determined by the <code>FindCMSIS</code> module. This is actually rather simple. Again modify the <code>CMakeLists.txt</code> file. This time, add the following block just below the <code>project()</code> command:</p>
<div class="fragment"><div class="line">set(CMRX_ARCH arm)</div>
<div class="line">set(CMRX_HAL cmsis)</div>
<div class="line">include(CMRX)</div>
</div><!-- fragment --><p>This block tells the CMRX kernel, that it is expected to build for ARM architecture and that the HAL used is "CMSIS-compatible". This configuration will work as the <code>FindCMSIS</code> module found and recorded all the necessary HAL components.</p>
<p>The next step is to add the CMRX source tree so the kernel will actually be built using the given configuration. To achieve this, add one line, just below the block just inserted:</p>
<div class="fragment"><div class="line">add_subdirectory(cmrx)</div>
</div><!-- fragment --><p>This will tell CMake, that in subdirectory <code>cmrx</code> there is another part of the current project. This directory comes from CMRX git repository and contains its own CMakeLists.txt suitable for embedding into other projects.</p>
<p>Now you can configure the project and build it:</p>
<div class="fragment"><div class="line">cmake -B build</div>
<div class="line">cmake --build build</div>
</div><!-- fragment --><p>If everything went well, the FindCMSIS should find all the headers required by the CMRX, CMRX should detect that it is being built for the ARM architecture, build system shall be generated without any errors and the build should succeed.</p>
<h1><a class="anchor" id="autotoc_md26"></a>
Linking CMRX to the project</h1>
<p>Now your project contains a buildable instance of the CMRX kernel, but the kernel is not used by your project yet. In order to achieve this a few more modifications are needed.</p>
<p>CMRX itself is built as a static library called <code>cmrx</code>. In order to use CMRX, you have to link this library to your project. Additionally, CMRX performs linker script management. This is necessary to make memory protection work seamlessly. To achieve this a special, CMRX-specific command exists: <code>add_firmware</code>.</p>
<p>This command is a wrapper around <code>add_executable</code> normally used to define firmware files that adds post-build target to update linker scripts.</p>
<p>Lets start by linking CMRX library to the main executable: At the very bottom of the CMakeLists.txt there is <code>target_link_libraries</code> command. Update it to look like this</p>
<div class="fragment"><div class="line">target_link_libraries(${CMAKE_PROJECT_NAME}</div>
<div class="line">    stm32cubemx</div>
<div class="line">    # Add user defined libraries</div>
<div class="line">    cmrx</div>
<div class="line">    aux_systick</div>
<div class="line">    )</div>
</div><!-- fragment --><p>While we were here, we added one additional library - <code>aux_systick</code>. Library <code>aux_systick</code> contains the implementation of SysTick-based kernel timing provider. The reason why it is implemented as a separate library is, that CMRX allows you to implement your own timing provider if you want to use some other timing source, e.g. for low power applications where SysTick is going to be shut down.</p>
<p>Next, find the line:</p>
<div class="fragment"><div class="line">add_executable(${CMAKE_PROJECT_NAME})</div>
</div><!-- fragment --><p>And change it to:</p>
<div class="fragment"><div class="line">add_firmware(${CMAKE_PROJECT_NAME})</div>
</div><!-- fragment --><p>Lastly, one final modification to CMake project generated by CubeMX is required. CubeMX configures the toolchain to use the linker script it generated. This will collide with instructions CMRX provides to use the linker script CMRX generated. The command added by CubeMX needs to be supressed.</p>
<p>This can be done in the file <code>cmake/gcc-arm-none-eabi.cmake</code> by commenting out (or removing) the following line:</p>
<div class="fragment"><div class="line">set(CMAKE_C_LINK_FLAGS &quot;${CMAKE_C_LINK_FLAGS} -T \&quot;${CMAKE_SOURCE_DIR}/stm32h753zitx_flash.ld\&quot;&quot;)</div>
</div><!-- fragment --><p>For now this is the last change in CMake files. We may proceed to modifying the source code to actually start the kernel upon firmware startup.</p>
<p>To achieve this, two calls have to be made. First, it is necessary to initialize the timing provider. To initialize the SysTick-based timing provider, following function has to be called in the <code>main()</code> function:</p>
<div class="fragment"><div class="line">timing_provider_setup(1);</div>
</div><!-- fragment --><p>This function is declared in the header file <code>cmrx/extra/systick.h</code>. The argument to this function is amount of time between two consecutive SysTick calls in milliseconds.</p>
<p>SysTick-based timing provider is CPU-agnostic. It does not know anything about HAL organization. For it to be able to provide correct timing, you need to provide a callback function that provides (current) CPU frequency. We'll add this callback here as well.</p>
<p>Next change is to <code>main.c</code> file is to add a call to <code><a class="el" href="group__os.html#gac0d275303ced3f7617b7d71fd1464687">os_start()</a></code> function. This function will actually boot the kernel.</p>
<p>With these three changes and required header includes the <code>Core/Src/main.c</code> file should look like this (unmodified portions left out):</p>
<div class="fragment"><div class="line">...</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* USER CODE END Header */</span></div>
<div class="line"><span class="comment">/* Includes ------------------------------------------------------------------*/</span></div>
<div class="line">#include <span class="stringliteral">&quot;main.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Private includes ----------------------------------------------------------*/</span></div>
<div class="line"><span class="comment">/* USER CODE BEGIN Includes */</span></div>
<div class="line"><span class="preprocessor">#include &lt;extra/systick.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cmrx/cmrx.h&gt;</span></div>
<div class="line"><span class="comment">/* USER CODE END Includes */</span></div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Private user code ---------------------------------------------------------*/</span></div>
<div class="line"><span class="comment">/* USER CODE BEGIN 0 */</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Callback providing current CPU frequency to SysTick timing provider */</span></div>
<div class="line">long <a class="code hl_function" href="group__api__timing.html#gaa7613a35fc20c795f3fcfe3042100769">timing_get_current_cpu_freq</a>(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> SystemCoreClock;</div>
<div class="line">}</div>
<div class="line"><span class="comment">/* USER CODE END 0 */</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line">  <span class="comment">/* USER CODE BEGIN 1 */</span></div>
<div class="line">  <a class="code hl_function" href="group__aux__systick.html#gac72eb3fe338346006ca3089ca0898867">timing_provider_setup</a>(1);</div>
<div class="line">  <span class="comment">/* USER CODE END 1 */</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">/* MCU Configuration--------------------------------------------------------*/</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">/* Reset of all peripherals, Initializes the Flash interface and the Systick. */</span></div>
<div class="line">  HAL_Init();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">/* USER CODE BEGIN Init */</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">/* USER CODE END Init */</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">/* Configure the system clock */</span></div>
<div class="line">  SystemClock_Config();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">/* USER CODE BEGIN SysInit */</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">/* USER CODE END SysInit */</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">/* Initialize all configured peripherals */</span></div>
<div class="line">  <span class="comment">/* USER CODE BEGIN 2 */</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">/* USER CODE END 2 */</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">/* Infinite loop */</span></div>
<div class="line">  <span class="comment">/* USER CODE BEGIN WHILE */</span></div>
<div class="line">  <a class="code hl_define" href="group__os.html#gac0d275303ced3f7617b7d71fd1464687">os_start</a>();</div>
<div class="line">    <span class="comment">/* USER CODE END WHILE */</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* USER CODE BEGIN 3 */</span></div>
<div class="line">  <span class="comment">/* USER CODE END 3 */</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">...</div>
<div class="ttc" id="agroup__api__timing_html_gaa7613a35fc20c795f3fcfe3042100769"><div class="ttname"><a href="group__api__timing.html#gaa7613a35fc20c795f3fcfe3042100769">timing_get_current_cpu_freq</a></div><div class="ttdeci">long timing_get_current_cpu_freq(void)</div><div class="ttdoc">Provide information on the current CPU speed.</div></div>
<div class="ttc" id="agroup__aux__systick_html_gac72eb3fe338346006ca3089ca0898867"><div class="ttname"><a href="group__aux__systick.html#gac72eb3fe338346006ca3089ca0898867">timing_provider_setup</a></div><div class="ttdeci">void timing_provider_setup(int interval_ms)</div><div class="ttdoc">Setup the timing provider.</div><div class="ttdef"><b>Definition</b> systick.c:19</div></div>
<div class="ttc" id="agroup__os_html_gac0d275303ced3f7617b7d71fd1464687"><div class="ttname"><a href="group__os.html#gac0d275303ced3f7617b7d71fd1464687">os_start</a></div><div class="ttdeci">#define os_start(core)</div><div class="ttdef"><b>Definition</b> cmrx.h:22</div></div>
</div><!-- fragment --><p>Note that careful placement of both includes and source code is necessary as CubeMX will remove any changes placed outside blocks delimited by comments <code>USER CODE BEGIN</code> and <code>USER CODE END</code> next time the code is generated by CubeMX.</p>
<p>One last blocker CubeMX creates for us are predefined IRQ handlers. If you build the project now, you'll see that <code>PendSV_Handler</code>, <code>SysTick_Handler</code> and <code>SVC_Handler</code> have multiple definitions. One comes from CubeMX and another comes from CMRX.</p>
<p>This can be quickly fixed in CubeMX by opening <code>System Core</code> -&gt; <code>NVIC</code> configuration page and selecting <code>Code Generation</code> tab. There, "Generate ISR handler" should be unchecked for "Pendable request for system service", "System service call via SWI 
instruction" and "System tick timer". After the code is generated again it should build without any errors on duplicate symbols.</p>
<div class="image">
<img src="cubemx-isr-config.png" alt=""/>
<div class="caption">
ISR Code Generation Configuration</div></div>
    <p>At this stage you have integrated the CMRX kernel into your CubeMX project! Code won't build yet because we are missing the CMRX standard library and some application code to run. Now it is time to write the blinky application itself.</p>
<h1><a class="anchor" id="autotoc_md30"></a>
Creating the blinky application</h1>
<p>Blinky application does a simple thing: it periodically turns a LED diode on and off. We will implement blinky as a CMRX userspace application. The advantage of this design is that blinky will be isolated from the rest of the system by the MPU. This means that a memory access error can't damage kernel nor any other task in the system.</p>
<p>Lets start by creating a skeleton of the application. First, create a directory <code>Core/Src/blinky</code>. The exact path does not matter but lets keep things nice and tidy and create blinky its own directory. In this directory, create two files: <code>Core/Src/blinky/CMakeLists.txt</code>:</p>
<div class="fragment"><div class="line">set(blinky_SRCS blinky.c)</div>
<div class="line">add_application(blinky ${blinky_SRCS})</div>
<div class="line">target_link_libraries(blinky PRIVATE stdlib stm32cubemx_headers)</div>
</div><!-- fragment --><p>This <code>CMakeLists.txt</code> file contains CMRX-specific command <code>add_application()</code> which is a wrapper around <code>add_library()</code> command. It ensures that proper linker script management is performed. Next this application links against several libraries. First is <code>stlib</code> - a standard library that gives the application access to the system call interface. Another one is a library we will cover later in this guide. Now you need to know that this library exports information on CubeMX HAL include paths and defines.</p>
<p>The source code of <code>Core/Src/blinky/blinky.c</code> will be a bit more verbose than usual. Aside from defining the main function for the blinky application, we also need to define the application itself. Moreover, as said above, CMRX will make sure that the blinky application can only access its own private data and nothing else. The problem is that blinky, in its nature, behaves as a device driver - it makes access to GPIO ports in order to light up LEDs.</p>
<p>So the code in <code>blinky.c</code> will do four things:</p><ul>
<li>define main function for the blinky application</li>
<li>define the blinky application so CMRX knows that there is such application</li>
<li>grant the blinky application access to GPIO ports</li>
<li>define a thread that will be automatically started, running the main function for the blinky application</li>
</ul>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cmrx/application.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stm32h7xx_hal.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;main.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cmrx/ipc/timer.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdbool.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Main function for the blinky application */</span></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span> blinky_main(<span class="keywordtype">void</span> * data)</div>
<div class="line">{</div>
<div class="line">    (void) data;</div>
<div class="line">    <span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div>
<div class="line">        HAL_GPIO_WritePin(LED_GREEN_GPIO_Port, LED_GREEN_Pin, GPIO_PIN_SET);</div>
<div class="line">        <a class="code hl_function" href="group__api__timer.html#ga6987ccb3233088dddefcf26bb39f249a">usleep</a>(500000);</div>
<div class="line">        HAL_GPIO_WritePin(LED_GREEN_GPIO_Port, LED_GREEN_Pin, GPIO_PIN_RESET);</div>
<div class="line">        <a class="code hl_function" href="group__api__timer.html#ga6987ccb3233088dddefcf26bb39f249a">usleep</a>(500000);</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Grant the blinky application access to the GPIOA - GPIOE peripheral */</span></div>
<div class="line"><a class="code hl_define" href="group__api__init.html#gaef7fd4ff3de50fb8b7bb9d5b51363278">OS_APPLICATION_MMIO_RANGES</a>(blinky, 0x58020000, 0x58023000, 0x0, 0x0);</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Declare the blinky application */</span></div>
<div class="line"><a class="code hl_define" href="group__api__init.html#gab5f63b29702312bedfe955e8465891cd">OS_APPLICATION</a>(blinky);</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Tell CMRX to automatically start a thread using `blinky_main` as an</span></div>
<div class="line"><span class="comment"> * entrypoint and having thread priority of 32 */</span></div>
<div class="line"><a class="code hl_define" href="group__api__init.html#gab0cfed2a7b7800c9b487db972328ef5d">OS_THREAD_CREATE</a>(blinky, blinky_main, <a class="code hl_define" href="group__api.html#ga070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, 32);</div>
<div class="ttc" id="agroup__api__init_html_gab0cfed2a7b7800c9b487db972328ef5d"><div class="ttname"><a href="group__api__init.html#gab0cfed2a7b7800c9b487db972328ef5d">OS_THREAD_CREATE</a></div><div class="ttdeci">#define OS_THREAD_CREATE(application, entrypoint, data, priority, core)</div><div class="ttdoc">Thread autostart facility.</div><div class="ttdef"><b>Definition</b> application.h:92</div></div>
<div class="ttc" id="agroup__api__init_html_gab5f63b29702312bedfe955e8465891cd"><div class="ttname"><a href="group__api__init.html#gab5f63b29702312bedfe955e8465891cd">OS_APPLICATION</a></div><div class="ttdeci">#define OS_APPLICATION(application)</div><div class="ttdoc">Declare userspace process.</div><div class="ttdef"><b>Definition</b> application.h:58</div></div>
<div class="ttc" id="agroup__api__init_html_gaef7fd4ff3de50fb8b7bb9d5b51363278"><div class="ttname"><a href="group__api__init.html#gaef7fd4ff3de50fb8b7bb9d5b51363278">OS_APPLICATION_MMIO_RANGES</a></div><div class="ttdeci">#define OS_APPLICATION_MMIO_RANGES(application, from, to, from2, to2)</div><div class="ttdef"><b>Definition</b> application.h:43</div></div>
<div class="ttc" id="agroup__api__timer_html_ga6987ccb3233088dddefcf26bb39f249a"><div class="ttname"><a href="group__api__timer.html#ga6987ccb3233088dddefcf26bb39f249a">usleep</a></div><div class="ttdeci">__SYSCALL int usleep(unsigned microseconds)</div><div class="ttdoc">Suspend thread execution for short time.</div><div class="ttdef"><b>Definition</b> timer.c:4</div></div>
<div class="ttc" id="agroup__api_html_ga070d2ce7b6bb7e5c05602aa8c308d0c4"><div class="ttname"><a href="group__api.html#ga070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a></div><div class="ttdeci">#define NULL</div><div class="ttdoc">Name the null pointer.</div><div class="ttdef"><b>Definition</b> defines.h:63</div></div>
</div><!-- fragment --><p>Note that the name <code>blinky</code> used in macros inside <code>blinky.c</code> must be the same as the name <code>blinky</code> used in the <code>add_application()</code> function in CMakeLists.txt.</p>
<p>If the name differs then the build will fail as CMRX expects that these two names match.</p>
<p>The macro <code>OS_APPLICATION_MMIO_RANGES</code> allows to define up to two arbitrary ranges of memory accessible to the application. These ranges are defined by a pair of starting and ending address. Without specifying the address range of GPIO peripherals blinky won't be able to blink the LED.</p>
<p>Addresses passed to this macro have several rules imposed by the CPU itself:</p><ul>
<li>Block size (end address - start address) must be a power of two value larger than 256</li>
<li>Start address must be aligned to size of the block. This means that if block size is e.g. 256, then the start address must have alignment of 256 bytes.</li>
</ul>
<h1><a class="anchor" id="autotoc_md33"></a>
CubeMX HAL tweaks</h1>
<p>Here we came across a tricky design feature of CubeMX HAL (which is similar to many other HALs actually): We want to include a HAL header from within application code. The application code has to be compiled into static library (to aid automatic memory protection facilities).</p>
<p>CubeMX generates target that provides access to these headers - <code>stm32cubemx</code>. The problem lies in the fact that this target is defined as <code>INTERFACE</code> library. This, in CMake terms, means that source files on this library will be copied into every target that links against it. Linking <code>blinky</code> application to <code>stm32cubemx</code> target would mean we end up with two copies of HAL.</p>
<p>A workaround for this problem may be to extract includes and compile definitions from <code>stm32cubemx</code> and create another target proving the very same information. Fortunately, this can be done in an automated way. Append the following block of code into <code>CMakeLists.txt</code> file just after the subdirectory <code>cmake/stm32cubemx</code> was added:</p>
<div class="fragment"><div class="line">get_target_property(CUBEMX_INCLUDE_DIRECTORIES stm32cubemx INTERFACE_INCLUDE_DIRECTORIES)</div>
<div class="line">get_target_property(CUBEMX_COMPILE_DEFINITIONS stm32cubemx INTERFACE_COMPILE_DEFINITIONS)</div>
<div class="line"> </div>
<div class="line">add_library(stm32cubemx_headers INTERFACE)</div>
<div class="line">target_include_directories(stm32cubemx_headers INTERFACE ${CUBEMX_INCLUDE_DIRECTORIES})</div>
<div class="line">target_compile_definitions(stm32cubemx_headers INTERFACE ${CUBEMX_COMPILE_DEFINITIONS})</div>
</div><!-- fragment --><p>This piece of code will create <code>INTERFACE</code> library <code>stm32cubemx_headers</code> that will provide same compile definitions and include paths as the <code>stm32cubemx</code> but won't inject any source files. We can link the blinky application against this library to get correct include path to <code>stm32h7xx_hal.h</code> file. Applications can link against this library in order use correct include paths and compiler definitions.</p>
<h1><a class="anchor" id="autotoc_md35"></a>
Adding blinky application to the build</h1>
<p>Very last step is to add this application to the build. To do so, two lines have to be added into master <code>CMakeLists.txt</code>.</p>
<p>Just after the line </p><div class="fragment"><div class="line">add_subdirectory(cmake/stm32cubemx)</div>
</div><!-- fragment --><p>add another line: </p><div class="fragment"><div class="line">add_subdirectory(Core/Src/blinky)</div>
</div><!-- fragment --><p>This will add source code for the blinky application into the build.</p>
<p>To include the blinky application into the firmware, we need to link it to the application. This is done using CMRX-specific command <code>target_add_applications()</code>. This command is essentially a wrapper around <code>target_link_libraries()</code> that automatically manages linker scripts. Add following line at the very end of the <code>CMakeLists.txt</code>:</p>
<div class="fragment"><div class="line">target_add_applications(${CMAKE_PROJECT_NAME}</div>
<div class="line">    blinky</div>
<div class="line">)</div>
</div><!-- fragment --><p>This is it! You have created your first fully memory protected application running on top of CMRX operating system. You can build the project now. You should get file <code>build/cmrx-cubemx-example.elf</code> which contains the application firmware.</p>
<h1><a class="anchor" id="autotoc_md37"></a>
Flashing the application</h1>
<p>There are multiple ways of flashing the firmware available. This guide will use one of IDE-agnostic ways: direct use of openocd and gdb.</p>
<p>OpenOCD is a gateway between your debugger probe and the debugger used on your PC.</p>
<p>Proceed by connecting your Nucleo board (ST-Link side) to the computer via USB. Make sure that ST-Link probe is visible by the operating system.</p>
<p>Now execute the following command in terminal:</p>
<div class="fragment"><div class="line">openocd -f interface/stlink.cfg -f target/stm32h7x.cfg</div>
</div><!-- fragment --><p>This will start openocd and connect it to the ST-Link probe on your Nucleo board, detect the connected CPU and wait for connection by debugger.</p>
<p>Next, once your firmware is built, run GDB in another terminal:</p>
<div class="fragment"><div class="line">gdb ~/projects/cmrx-cubemx-example/build/cmrx-cubemx-example.elf</div>
</div><!-- fragment --><p>In this GDB instance, the following sequence of commands will perform following actions: 1) GDB will connect to the OpenOCD which will serve as GDB server and provide connection to the CPU on your Nucleo board 2) Load the CPU on the Nucleo board with the firmware just built 3) Start executing the firmware</p>
<div class="fragment"><div class="line">target extended-remote localhost:3333</div>
<div class="line">load</div>
<div class="line">run</div>
</div><!-- fragment --><p>If you did everything correctly, you should see that the green LED on the Nucleo board will blink roughly in 0.5 second interval.</p>
<p>Congratulations! You have just successfully created, built and flashed your first CMRX-based project! </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.7-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</div>
</body>
</html>
