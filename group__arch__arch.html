<!-- HTML header for doxygen 1.9.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>C Microkernel Realtime eXecutive: Porting layer</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="all">
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">C Microkernel Realtime eXecutive
   </div>
   <div id="projectbrief">Realtime Operating System for Cortex-M based microcontrollers</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__arch__arch.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Porting layer<div class="ingroups"><a class="el" href="group__os.html">Kernel documentation</a> &raquo; <a class="el" href="group__arch.html">Architecture support</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Description of CMRX porting layer.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structArch__State__t.html">Arch_State_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ARM-specific architecture state of a thread.  <a href="structArch__State__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga406768807186211937d0ae289490231d" id="r_ga406768807186211937d0ae289490231d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__arch__arch.html#ga406768807186211937d0ae289490231d">os_ipi_sync_request</a> ()</td></tr>
<tr class="memdesc:ga406768807186211937d0ae289490231d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request Inter-processor synchronization.  <br /></td></tr>
<tr class="separator:ga406768807186211937d0ae289490231d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf585a2c2059dfbdc1bad79c7f370ea36" id="r_gaf585a2c2059dfbdc1bad79c7f370ea36"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__arch__arch.html#gaf585a2c2059dfbdc1bad79c7f370ea36">os_ipi_sync_release</a> ()</td></tr>
<tr class="memdesc:gaf585a2c2059dfbdc1bad79c7f370ea36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release cores waiting in inter-processor synchronization loop.  <br /></td></tr>
<tr class="separator:gaf585a2c2059dfbdc1bad79c7f370ea36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2a18c9a690c0de3735ef1f78abe1554" id="r_gaf2a18c9a690c0de3735ef1f78abe1554"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__arch__arch.html#gaf2a18c9a690c0de3735ef1f78abe1554">os_ipi_sync_probe</a> ()</td></tr>
<tr class="memdesc:gaf2a18c9a690c0de3735ef1f78abe1554"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if inter-processor synchronization is requested.  <br /></td></tr>
<tr class="separator:gaf2a18c9a690c0de3735ef1f78abe1554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b1827c66da610023e93a6ad404bd38f" id="r_ga8b1827c66da610023e93a6ad404bd38f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__arch__arch.html#ga8b1827c66da610023e93a6ad404bd38f">os_request_context_switch</a> (bool activate)</td></tr>
<tr class="memdesc:ga8b1827c66da610023e93a6ad404bd38f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request context switch.  <br /></td></tr>
<tr class="separator:ga8b1827c66da610023e93a6ad404bd38f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08c83fbec4a92bba591402c53805f345" id="r_ga08c83fbec4a92bba591402c53805f345"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__arch__arch.html#ga08c83fbec4a92bba591402c53805f345">coreid</a> ()</td></tr>
<tr class="memdesc:ga08c83fbec4a92bba591402c53805f345"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide kernel with identification of current CPU core.  <br /></td></tr>
<tr class="separator:ga08c83fbec4a92bba591402c53805f345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac579ea1044d56f3f04887b8b21118826" id="r_gac579ea1044d56f3f04887b8b21118826"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__arch__arch.html#gac579ea1044d56f3f04887b8b21118826">os_smp_lock</a> ()</td></tr>
<tr class="memdesc:gac579ea1044d56f3f04887b8b21118826"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock the "big kernel lock".  <br /></td></tr>
<tr class="separator:gac579ea1044d56f3f04887b8b21118826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad026c280d52436bedf3e3643900d735f" id="r_gad026c280d52436bedf3e3643900d735f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__arch__arch.html#gad026c280d52436bedf3e3643900d735f">os_smp_unlock</a> ()</td></tr>
<tr class="memdesc:gad026c280d52436bedf3e3643900d735f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock the "big kernel lock".  <br /></td></tr>
<tr class="separator:gad026c280d52436bedf3e3643900d735f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c0d351c7f2f49293fe5907c2ac5d289" id="r_ga4c0d351c7f2f49293fe5907c2ac5d289"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__arch__arch.html#ga4c0d351c7f2f49293fe5907c2ac5d289">os_core_lock</a> ()</td></tr>
<tr class="memdesc:ga4c0d351c7f2f49293fe5907c2ac5d289"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock the current core This function ensures that no other code will interrupt the currently running core.  <br /></td></tr>
<tr class="separator:ga4c0d351c7f2f49293fe5907c2ac5d289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b7c981ccf3a59d00d3424fa768c71ea" id="r_ga7b7c981ccf3a59d00d3424fa768c71ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__arch__arch.html#ga7b7c981ccf3a59d00d3424fa768c71ea">os_core_unlock</a> ()</td></tr>
<tr class="memdesc:ga7b7c981ccf3a59d00d3424fa768c71ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock the current core Unlocks exclusive access to the current core.  <br /></td></tr>
<tr class="separator:ga7b7c981ccf3a59d00d3424fa768c71ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb3a0773a5b5be08c7e685cfad452648" id="r_gaeb3a0773a5b5be08c7e685cfad452648"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__arch__arch.html#gaeb3a0773a5b5be08c7e685cfad452648">os_core_sleep</a> ()</td></tr>
<tr class="memdesc:gaeb3a0773a5b5be08c7e685cfad452648"><td class="mdescLeft">&#160;</td><td class="mdescRight">Park current core This function is free to park current core in whatever way that will still allow the core to be woken up by external interrupts.  <br /></td></tr>
<tr class="separator:gaeb3a0773a5b5be08c7e685cfad452648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b816407f1b57d532407988a5da92716" id="r_ga2b816407f1b57d532407988a5da92716"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__arch__arch.html#ga2b816407f1b57d532407988a5da92716">os_memory_protection_start</a> ()</td></tr>
<tr class="memdesc:ga2b816407f1b57d532407988a5da92716"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start memory protection.  <br /></td></tr>
<tr class="separator:ga2b816407f1b57d532407988a5da92716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1e98b6b913a67b51e041e4e9002a399" id="r_gad1e98b6b913a67b51e041e4e9002a399"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__arch__arch.html#gad1e98b6b913a67b51e041e4e9002a399">mpu_init_stack</a> (int thread_id)</td></tr>
<tr class="memdesc:gad1e98b6b913a67b51e041e4e9002a399"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize MPU for stack of thread.  <br /></td></tr>
<tr class="separator:gad1e98b6b913a67b51e041e4e9002a399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccaca933ccccec5a6f6808252b4a5fbc" id="r_gaccaca933ccccec5a6f6808252b4a5fbc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__arch__arch.html#gaccaca933ccccec5a6f6808252b4a5fbc">mpu_restore</a> (const <a class="el" href="group__arch__arm__mpu.html#ga8fdd1416c938c54f8e1e9fca4b9f139a">MPU_State</a> *hosted_state, const <a class="el" href="group__arch__arm__mpu.html#ga8fdd1416c938c54f8e1e9fca4b9f139a">MPU_State</a> *parent_state)</td></tr>
<tr class="memdesc:gaccaca933ccccec5a6f6808252b4a5fbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load MPU settings.  <br /></td></tr>
<tr class="separator:gaccaca933ccccec5a6f6808252b4a5fbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad478154133b190e328ee2cd65a4a8b20" id="r_gad478154133b190e328ee2cd65a4a8b20"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__arch__arch.html#gad478154133b190e328ee2cd65a4a8b20">os_memory_protection_stop</a> ()</td></tr>
<tr class="memdesc:gad478154133b190e328ee2cd65a4a8b20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable memory protection.  <br /></td></tr>
<tr class="separator:gad478154133b190e328ee2cd65a4a8b20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ee8f29f3009ad125af02a612603504f" id="r_ga9ee8f29f3009ad125af02a612603504f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__arch__arch.html#ga9ee8f29f3009ad125af02a612603504f">os_rpc_call</a> (uint32_t arg0, uint32_t arg1, uint32_t arg2, uint32_t arg3)</td></tr>
<tr class="memdesc:ga9ee8f29f3009ad125af02a612603504f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kernel implementation of rpc_call syscall.  <br /></td></tr>
<tr class="separator:ga9ee8f29f3009ad125af02a612603504f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b0268c1c8ecd0d6e3194f0f52be350c" id="r_ga2b0268c1c8ecd0d6e3194f0f52be350c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__arch__arch.html#ga2b0268c1c8ecd0d6e3194f0f52be350c">os_rpc_return</a> (uint32_t arg0, uint32_t arg1, uint32_t arg2, uint32_t arg3)</td></tr>
<tr class="memdesc:ga2b0268c1c8ecd0d6e3194f0f52be350c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kernel implementation of rpc_return syscall.  <br /></td></tr>
<tr class="separator:ga2b0268c1c8ecd0d6e3194f0f52be350c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga439fecf5da5136ef742a9a568c0f197d" id="r_ga439fecf5da5136ef742a9a568c0f197d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__arch__arch.html#ga439fecf5da5136ef742a9a568c0f197d">os_thread_initialize_arch</a> (struct <a class="el" href="structOS__thread__t.html">OS_thread_t</a> *thread)</td></tr>
<tr class="memdesc:ga439fecf5da5136ef742a9a568c0f197d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize architecture-specific initialization of thread.  <br /></td></tr>
<tr class="separator:ga439fecf5da5136ef742a9a568c0f197d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1e4c4f6735a5acd050873acdb00cdbf" id="r_gaa1e4c4f6735a5acd050873acdb00cdbf"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__arch__arch.html#gaa1e4c4f6735a5acd050873acdb00cdbf">static_init_thread_count</a> ()</td></tr>
<tr class="memdesc:gaa1e4c4f6735a5acd050873acdb00cdbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides count of statically initialized threads.  <br /></td></tr>
<tr class="separator:gaa1e4c4f6735a5acd050873acdb00cdbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab06a63362ae820b797a3bf0b1c6386a0" id="r_gab06a63362ae820b797a3bf0b1c6386a0"><td class="memItemLeft" align="right" valign="top">const struct <a class="el" href="structOS__thread__create__t.html">OS_thread_create_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__arch__arch.html#gab06a63362ae820b797a3bf0b1c6386a0">static_init_thread_table</a> ()</td></tr>
<tr class="memdesc:gab06a63362ae820b797a3bf0b1c6386a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides address of statically initialized thread table.  <br /></td></tr>
<tr class="separator:gab06a63362ae820b797a3bf0b1c6386a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4128fe30c4eef560ae2dc025e89abf2" id="r_gad4128fe30c4eef560ae2dc025e89abf2"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__arch__arch.html#gad4128fe30c4eef560ae2dc025e89abf2">static_init_process_count</a> ()</td></tr>
<tr class="memdesc:gad4128fe30c4eef560ae2dc025e89abf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides count of statically initialized processes.  <br /></td></tr>
<tr class="separator:gad4128fe30c4eef560ae2dc025e89abf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40ff64621b791a06874bb7ca27a9164e" id="r_ga40ff64621b791a06874bb7ca27a9164e"><td class="memItemLeft" align="right" valign="top">const struct <a class="el" href="structOS__process__definition__t.html">OS_process_definition_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__arch__arch.html#ga40ff64621b791a06874bb7ca27a9164e">static_init_process_table</a> ()</td></tr>
<tr class="memdesc:ga40ff64621b791a06874bb7ca27a9164e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides address of statically intialized process table.  <br /></td></tr>
<tr class="separator:ga40ff64621b791a06874bb7ca27a9164e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Description of CMRX porting layer. </p>
<p>CMRX offers primitives to perform unaddressed synchronization unlike <a class="el" href="group__api__signal.html#ga31cb184e9e6351ce176c3324b7b49a24">kill()</a> call, which allows thread to send a signal to another thread, API in this group uses memory location as a designator, rather than specific thread.</p>
<p>CMRX expects that the following functions are provided by architecture support layer. If creating new layer, these functions have to be implemented.</p>
<p>This list is by no means definitive. Each architecture will require its own mechanisms to be implemented so the kernel can actually work. Mechanisms CMRX requires to be present in the architecture and be implemented are:</p><ul>
<li>service / system call mechanism that allows to call the kernel from usermode code</li>
<li>memory protection mechanism</li>
<li>mechanism allowing to schedule and then perform thread switching</li>
</ul>
<p>Similarly, some of kernel syscalls are directly implemented by the architecture support layer as there is no way for kernel to know how platform will implement given mechanisms. This covers mostly the RPC call / return syscalls and signal delivery.</p>
<p>To create a port of CMRX to the new architecture a few steps are needed. This guide roughly describes them in general terms and outlines items that have to be provided which are not immediately obvious from the portin layer API.</p>
<p>In the following text, several terms will be used:</p>
<p>Architecture - refers to the CPU family which determines most of target CPU functionality. In case of CMRX, ports are mainly done to support certain CPU architecture rather than specific platform (see next). Examples of architectures are: ARM (Cortex-M), RISC-V (RV32/64-E).</p>
<p>Platform - refers to specific subfamily of CPU. This subfamily may further determine presence of absence of certain CPU features. CMRX mostly don't care about presence of features it does not directly support or require. Features, that are required by CMRX (especially memory protection) must be present, otherwise it is not possible to port CMRX to such architecture reliably. In case of ARM, such platforms might be Cortex-M0+, Cortex-M4 or Cortex-M4F.</p>
<p>Port - refers to specific vendor implementation of the platform. In case of CMRX, specifically for the ARM architecture, all ports are covered by generic port named "CMSIS". This ports expects that your vendor's SDK provides CMSIS-compatible headers. The CMRX build system supports creation of ports, but as long as there is technical solution available that does not require port creation, it should be avoided. In CMRX terminology port refers to the same thing as term "HAL" does.</p>
<h1><a class="anchor" id="anatomy"></a>
Anatomy of CMRX port</h1>
<p>CMRX kernel is divided into two parts which are interconnected and together form a full CMRX kernel. One part is the platform-independent code that mostly covers the CMRX API and common functionality, like scheduler, timer implementation, etc. Another part provides architecture- and platform-specific functionality needed for the former part to be able to execute.</p>
<p>Following text describes the latter, the porting layer. Porting layer basically consists of three (possibly four) parts:</p>
<p>CMake script to define actions specific to correctly support the target architecture C headers containing definitions both required by platform-independent part and required internally by the port itself. C sources containing implementation of the port. Optionally, there might be some scripts required to support architecture-specific features.</p>
<h1><a class="anchor" id="script"></a>
CMake script</h1>
<p>Architecture support script is expected to be stored in <code>&lt;root_dir&gt;/cmake/arch/&lt;architecture&gt;/&lt;port&gt;/CMRX.cmake</code> file. This file will be included automatically, once <code>include(CMRX)</code> is hit in project's <code>CMakeLists.txt</code>.</p>
<p>This file is expected to define two functions: add_firmware() target_add_application()</p>
<h1><a class="anchor" id="headers"></a>
C headers</h1>
<p>All headers that provide support for some specific platform shall be stored in <code>&lt;root_dir&gt;/include/cmrx/&lt;architecture&gt;/&lt;port&gt;/arch/</code> directory. This directory will automatically be added into include paths of CMRX kernel. The code can then refer to headers inside this directory as using <code>#include &lt;arch/header.h&gt;</code>.</p>
<p>This directory shall contain all the header files your port contains. There are no limits on what files you create and how you name them. CMRX platform-independent part will not include almost none of them.</p>
<p>The platform-independent part of CMRX expects just a few files to exist in this directory. They will be directly included by the platform-independent part so they shall only contain entities described below and shall not include any other headers, if possible.</p>
<h2><a class="anchor" id="corelocal_h"></a>
corelocal.h</h2>
<p>This file has to contain two entities. They might be implemented as macros, static inline functions or any other kind of function, as needed by the platform.</p>
<p>coreid() - provides ID of the currently running core. For uni-processor systems, this can be a macro hardcoded to return value of 0. OS_NUM_CORES - usually a macro, that provides information on amount of cores present in the system.</p>
<h2><a class="anchor" id="mpu_h"></a>
mpu.h</h2>
<p>This file has to contain one type definition. Portable part of kernel expects its existence:</p>
<p>struct <a class="el" href="structMPU__Registers.html" title="Convenience structure which groups RBAR and RASR register for one MPU region together.">MPU_Registers</a> - the internal structure of this type is not important for the portable part of CMRX kernel, but the size of this structure must be large enough so that the porting layer for the architecture will be able to store memory protection unit state of CPU when swapping threads in and out. The design of this structure is entirely up on the designed of the port. Portable part of CMRX doesn't use the data stored there.</p>
<h2><a class="anchor" id="sysenter_h"></a>
sysenter.h</h2>
<p>This file has to define two objects:</p>
<p>__SYSCALL - this macro shall expand to list of attributes that function serving as the syscall entrypoint has to have. It can be empty if there are none, but has to be defined.</p>
<p><a class="el" href="group__os__syscall.html#ga7b1388f7bd14b83bd3f8f773fbf3375b" title="Perform syscall.">__SVC()</a> - this can be either macro or a function, depending on the architecture. It shall expand to or directly execute architecture-specific means of calling the system calls. It has to accept one argument, which is a system call ID.</p>
<h1><a class="anchor" id="sources"></a>
Port implementation sources</h1>
<p>Port has to implement certain functions that are expected to be provided by it. Sources of the port can be stored in directory <code>&lt;root_dir&gt;/src/os/arch/&lt;architecture&gt;</code>. CMRX build system will expect that <code>CMakeLists.txt</code> file exist there and will include it automatically. This <code>CMakeLists.txt</code> file shall update the target <code>os</code> to include sources located in the architecture support directory. This way the platform-independent portion will be extended by the necessary platform support. If platform support requires linking of any additional libraries, such as HAL, then commands to let the <code>os</code> target link them should be present in CMakeLists.txt in this directory as well.</p>
<p>These sources shall provide implementation of functions outlined in this section of the manual. If port fails to provide the implementation for any of them, build will most probably fail. Port has to accept the API and semantics of functions.</p>
<p>To provide full set of functionality, some architecture-specific mechanisms might need to be implemented by the port. CMRX porting layer does not directly prescribe, which these are as it is not possible to determine them in advance. It is up to the designer of the port to figure out what exact mechanisms are these.</p>
<p>For CMRX purposes, mechanisms, which are known to be needed are:</p>
<p>mechanism to handle "service call". The "service call" is a mechanism of transferring control from the user space into kernel space. This mechanism has to be able to provide numeric value of service which was called.</p>
<p>Optionally, additional mechanisms can be implemented in the port, such as:</p>
<p>mechanism to handle certain types of program faults. This handler might be useful in determining if the root cause of the fault was a memory protection violation and to send the signal to kill the failing thread.</p>
<p>mechanism to defer thread switch. CMRX is written in a way, that thread switch is expected to be executed after the system call / interrupt service handler or kernel callback has finished its run. If target architecture doesn't support this behavior, this mechanism does not need to be implemented.</p>
<p>Using this API, a programmer can write code that notifies unknown recipient. All that is needed for notifier and waiter for this mechanism to work is to agree upon memory location used as notification object.</p>
<p>Any object can be used as the object itself is not examined or used during the notification. It is just a convenient way on determining the notification ID.</p>
<p>It allows multiple object to wait for single object and thus can serve as a building block for more advanced primitives such as semaphores or queues. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga08c83fbec4a92bba591402c53805f345" name="ga08c83fbec4a92bba591402c53805f345"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08c83fbec4a92bba591402c53805f345">&#9670;&#160;</a></span>coreid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned coreid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provide kernel with identification of current CPU core. </p>
<p>Kernel calls this function if it is configured for SMP. This function is part of the porting layer but does not need to be implemented in port. If the architecture does not provide unified way of determining which core is the one currently executing this code, then the implementation of this method may be left to the user. </p><dl class="section return"><dt>Returns</dt><dd>ID of the currently running code </dd></dl>

</div>
</div>
<a id="gad1e98b6b913a67b51e041e4e9002a399" name="gad1e98b6b913a67b51e041e4e9002a399"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1e98b6b913a67b51e041e4e9002a399">&#9670;&#160;</a></span>mpu_init_stack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mpu_init_stack </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>thread_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize MPU for stack of thread. </p>
<p>Performs initialization of the MPU to enable the given thread to use the stack. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread_id</td><td>Thread stack has to be initialized for </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaccaca933ccccec5a6f6808252b4a5fbc" name="gaccaca933ccccec5a6f6808252b4a5fbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaccaca933ccccec5a6f6808252b4a5fbc">&#9670;&#160;</a></span>mpu_restore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mpu_restore </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__arch__arm__mpu.html#ga8fdd1416c938c54f8e1e9fca4b9f139a">MPU_State</a> *&#160;</td>
          <td class="paramname"><em>hosted_state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__arch__arm__mpu.html#ga8fdd1416c938c54f8e1e9fca4b9f139a">MPU_State</a> *&#160;</td>
          <td class="paramname"><em>parent_state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load MPU settings. </p>
<p>Loads MPU settings for default amount of regions from off-CPU buffer. This is suitable for store-resume during task switching. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hosted_state</td><td>MPU state buffer for the current host process </td></tr>
    <tr><td class="paramname">parent_state</td><td>MPU state buffer for the parent process </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1efbfe606317fd469d8fc187a4cb9a79" name="ga1efbfe606317fd469d8fc187a4cb9a79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1efbfe606317fd469d8fc187a4cb9a79">&#9670;&#160;</a></span>os_boot_thread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void os_boot_thread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__api.html#gaae12e635a9412afabedb95620d3e2ffe">Thread_t</a>&#160;</td>
          <td class="paramname"><em>boot_thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start executing thread. </p>
<p>Used to actually start executing in thread mode just after the kernel has been initialized and is ready to start the first thread. This function has to perform CPU switch from privileged mode in which kernel runs into unprivileged mode in which threads are supposed to run. Thread passed to this function is in state ready to be executed by normal kernel thread switching mechanism on this platform. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">boot_thread</td><td>ID of thread that shall be started </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4c0d351c7f2f49293fe5907c2ac5d289" name="ga4c0d351c7f2f49293fe5907c2ac5d289"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c0d351c7f2f49293fe5907c2ac5d289">&#9670;&#160;</a></span>os_core_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void os_core_lock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lock the current core This function ensures that no other code will interrupt the currently running core. </p>
<p>It usually boils down to disabling interrupts. </p><dl class="section note"><dt>Note</dt><dd>Calling this function does <em>NOT</em> prevent another core from running code which will manipulate kernel data structures. If you want this behavior, use os_smp_lock(). </dd></dl>

</div>
</div>
<a id="gaeb3a0773a5b5be08c7e685cfad452648" name="gaeb3a0773a5b5be08c7e685cfad452648"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb3a0773a5b5be08c7e685cfad452648">&#9670;&#160;</a></span>os_core_sleep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void os_core_sleep </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Park current core This function is free to park current core in whatever way that will still allow the core to be woken up by external interrupts. </p>

</div>
</div>
<a id="ga7b7c981ccf3a59d00d3424fa768c71ea" name="ga7b7c981ccf3a59d00d3424fa768c71ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b7c981ccf3a59d00d3424fa768c71ea">&#9670;&#160;</a></span>os_core_unlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void os_core_unlock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlock the current core Unlocks exclusive access to the current core. </p>
<p>Usually it boils down to enabling interrupts. </p>

</div>
</div>
<a id="gaf2a18c9a690c0de3735ef1f78abe1554" name="gaf2a18c9a690c0de3735ef1f78abe1554"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf2a18c9a690c0de3735ef1f78abe1554">&#9670;&#160;</a></span>os_ipi_sync_probe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void os_ipi_sync_probe </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if inter-processor synchronization is requested. </p>
<p>Each core should call this function from time to time. If any other core calls for inter-processor synchronization, then core calling this function will be blocked in the call until the core which requested the synchronization doesn't release it. </p>

</div>
</div>
<a id="gaf585a2c2059dfbdc1bad79c7f370ea36" name="gaf585a2c2059dfbdc1bad79c7f370ea36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf585a2c2059dfbdc1bad79c7f370ea36">&#9670;&#160;</a></span>os_ipi_sync_release()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void os_ipi_sync_release </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release cores waiting in inter-processor synchronization loop. </p>
<p>This function will release all cores which are waiting in <a class="el" href="group__arch__arch.html#gaf2a18c9a690c0de3735ef1f78abe1554" title="Check if inter-processor synchronization is requested.">os_ipi_sync_probe()</a> function waiting for core which requested synchronization to release it. Failure to call this function after <a class="el" href="group__arch__arch.html#ga406768807186211937d0ae289490231d" title="Request Inter-processor synchronization.">os_ipi_sync_request()</a> was called will result in permanent halt of all other system cores. </p>

</div>
</div>
<a id="ga406768807186211937d0ae289490231d" name="ga406768807186211937d0ae289490231d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga406768807186211937d0ae289490231d">&#9670;&#160;</a></span>os_ipi_sync_request()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void os_ipi_sync_request </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Request Inter-processor synchronization. </p>
<p>This is minimalistic implementation for inter-processor synchronization request for Cortex-M processors. This implementation does not assume presence of any inter-processor interrupt mechanism. It assumes that each core checks for inter-processor sync every now and then. This function will block until all online cores call <a class="el" href="group__arch__arch.html#gaf2a18c9a690c0de3735ef1f78abe1554" title="Check if inter-processor synchronization is requested.">os_ipi_sync_probe()</a>. By doing so all cores remain synchronized and it is guarranteed they will do nothing. Then this function returns. </p>

</div>
</div>
<a id="ga6e29c6b6f3e6e761c076a0b28490da0e" name="ga6e29c6b6f3e6e761c076a0b28490da0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e29c6b6f3e6e761c076a0b28490da0e">&#9670;&#160;</a></span>os_kernel_shutdown()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void os_kernel_shutdown </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stop running the kernel. </p>
<p>Return to bare metal execution mode similar to one after CPU reset. This function should configure the CPU to continue execution in privileged mode not distinguishing between thread and kernel space. Once this mode is configured the function <a class="el" href="group__arch__arm__sched.html#gaa1fe4414a243f61c85e0a1d2fbd01440">cmrx_shutdown_handler()</a> should be executed.</p>
<p>This is a point of no return. Code here is free to destroy any previous context.</p>
<p>Stop running the kernel.</p>
<p>This is platform-specific way of how to shutdown the kernel. In this case an interrupt frame is forged on stack that will resemble a frame returning back to the <a class="el" href="group__arch__arm__sched.html#gaa1fe4414a243f61c85e0a1d2fbd01440">cmrx_shutdown_handler</a> function. The result of running this function will be that the processor leaves the handler mode, enters privileged thread mode and will be using MSP. </p>

</div>
</div>
<a id="ga2b816407f1b57d532407988a5da92716" name="ga2b816407f1b57d532407988a5da92716"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b816407f1b57d532407988a5da92716">&#9670;&#160;</a></span>os_memory_protection_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void os_memory_protection_start </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start memory protection. </p>
<p>Initialize hardware memory protection unit so that following conditions are met:</p><ul>
<li>RAM is not executable</li>
<li>kernel can execute all the flash and read/write all the RAM</li>
<li>FLASH can optionally be executable from userspace, if hardware is not capable enough to allow for fine-grained execution access. Kernel must be able to continue execution past this point. </li>
</ul>

</div>
</div>
<a id="gad478154133b190e328ee2cd65a4a8b20" name="gad478154133b190e328ee2cd65a4a8b20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad478154133b190e328ee2cd65a4a8b20">&#9670;&#160;</a></span>os_memory_protection_stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void os_memory_protection_stop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable memory protection. </p>
<p>Disables memory protection unit so that no rules are enforced by the hardware. The CPU state after this call should resemble MPU state after reset. </p>

</div>
</div>
<a id="ga770860e52c205dc2a7e865b80b0fca11" name="ga770860e52c205dc2a7e865b80b0fca11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga770860e52c205dc2a7e865b80b0fca11">&#9670;&#160;</a></span>os_process_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int os_process_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__api.html#ga36958e2082eecb09f367fa4aa3a9a84d">Process_t</a>&#160;</td>
          <td class="paramname"><em>process_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structOS__process__definition__t.html">OS_process_definition_t</a> *&#160;</td>
          <td class="paramname"><em>definition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create process using process definition. </p>
<p>Takes process definition and initializes MPU regions for process out of it. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">process_id</td><td>ID of process to be initialized </td></tr>
    <tr><td class="paramname">definition</td><td>process definition. This is constructed at compile time using OS_APPLICATION macros </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>E_OK if process was contructed properly, E_INVALID if process ID is already used or if process definition contains invalid section boundaries. E_OUT_OF_RANGE is returned if process ID requested is out of limits given by the size of process table. </dd></dl>

</div>
</div>
<a id="ga8b1827c66da610023e93a6ad404bd38f" name="ga8b1827c66da610023e93a6ad404bd38f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b1827c66da610023e93a6ad404bd38f">&#9670;&#160;</a></span>os_request_context_switch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void os_request_context_switch </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>activate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Request context switch. </p>
<p>This function is called by the platform independent part of the kernel when cpu_context structure is filled with valid data and context switch shall happen. The implementation of this function should configure the hardware in a way that context switch will happen as soon as kernel finishes its work and is ready to return the CPU back to the userspace code. </p>

</div>
</div>
<a id="ga0ef00a0f1fe50bb0af3bbf05cbdddfe3" name="ga0ef00a0f1fe50bb0af3bbf05cbdddfe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ef00a0f1fe50bb0af3bbf05cbdddfe3">&#9670;&#160;</a></span>os_reset_cpu()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void os_reset_cpu </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset the CPU. </p>
<p>This is architecture- (and possibly HAL-) specific way to reset the CPU. This function can be used before the kernel has been started or after it has been shut down. If there is no shutdown handler provided by the integrator then the default handler will call this function to reset the CPU automatically. </p>

</div>
</div>
<a id="ga9ee8f29f3009ad125af02a612603504f" name="ga9ee8f29f3009ad125af02a612603504f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ee8f29f3009ad125af02a612603504f">&#9670;&#160;</a></span>os_rpc_call()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int os_rpc_call </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>arg0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>arg2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>arg3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kernel implementation of rpc_call syscall. </p>
<p>This syscall has to validate the RPC service and method IDs, determine the address of RPC method and owning process. Then it has to transfer the control to RPC method in a manner that:</p><ul>
<li>method called will be able to access the first four arguments given to the <a class="el" href="group__api__rpc.html#ga896b17abf6ce670f5000ac4a0852393f">rpc_call()</a> call.</li>
<li>when method returns, the <a class="el" href="group__arch__arm__rpc.html#ga2b0268c1c8ecd0d6e3194f0f52be350c">os_rpc_return()</a> is triggered and will transfer the control back</li>
<li>to the calling code and process. </li>
</ul>

</div>
</div>
<a id="ga2b0268c1c8ecd0d6e3194f0f52be350c" name="ga2b0268c1c8ecd0d6e3194f0f52be350c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b0268c1c8ecd0d6e3194f0f52be350c">&#9670;&#160;</a></span>os_rpc_return()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int os_rpc_return </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>arg0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>arg2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>arg3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kernel implementation of rpc_return syscall. </p>
<p>This syscall has to return the control back to the code which called <a class="el" href="group__api__rpc.html#ga896b17abf6ce670f5000ac4a0852393f">rpc_call</a>. This has to be done in a way that the calling code will be able to access the return value of the RPC method. </p>

</div>
</div>
<a id="gabb3070fe93f5997763b5685b81288f5c" name="gabb3070fe93f5997763b5685b81288f5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb3070fe93f5997763b5685b81288f5c">&#9670;&#160;</a></span>os_set_syscall_return_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int os_set_syscall_return_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__api.html#gaae12e635a9412afabedb95620d3e2ffe">Thread_t</a>&#160;</td>
          <td class="paramname"><em>thread_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>retval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set return value of syscall for given thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread_id</td><td>Id of the thread whose exception handler is being modified </td></tr>
    <tr><td class="paramname">retval</td><td>value to store on the stack </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac579ea1044d56f3f04887b8b21118826" name="gac579ea1044d56f3f04887b8b21118826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac579ea1044d56f3f04887b8b21118826">&#9670;&#160;</a></span>os_smp_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void os_smp_lock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lock the "big kernel lock". </p>
<p>This function starts the critical section within kernel. Actions that happen within critical section can ever only happen on one CPU core and other cores must not motify the same data. Big kernel lock is used to lock thread table, stack allocation table and sleepers table.</p>
<p>This function is part of porting layer but depends heavily on target CPU. It may be left to be implemented by the user. If this function is called, the code should make sure that if this function is called on any other core before os_smp_unlock() is called that another call won't proceed. </p>

</div>
</div>
<a id="gad026c280d52436bedf3e3643900d735f" name="gad026c280d52436bedf3e3643900d735f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad026c280d52436bedf3e3643900d735f">&#9670;&#160;</a></span>os_smp_unlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void os_smp_unlock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlock the "big kernel lock". </p>
<p>This function ends the critical setion within kernel.</p>
<p>This function is part of the porting layer but depends heavily on target CPU. It may be left the be implemented by the user. Once this function is called the code must make sure that any other core potentially being blocked by parallel call to os_smp_lock() will be unlocked and continue execution. </p>

</div>
</div>
<a id="ga439fecf5da5136ef742a9a568c0f197d" name="ga439fecf5da5136ef742a9a568c0f197d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga439fecf5da5136ef742a9a568c0f197d">&#9670;&#160;</a></span>os_thread_initialize_arch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void os_thread_initialize_arch </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structOS__thread__t.html">OS_thread_t</a> *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalize architecture-specific initialization of thread. </p>
<p>This routine is called when thread has been created. It has opportunity to perform architecture-specific default-initialization of the thread. </p><dl class="section note"><dt>Note</dt><dd>To save some CPU cycles, you can define this function as an empty macro if it is not used. In that case the <a class="el" href="structArch__State__t.html">Arch_State_t</a> should be an empty structure. </dd></dl>

</div>
</div>
<a id="ga1f714f6892c35a090439a7071ddadf46" name="ga1f714f6892c35a090439a7071ddadf46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f714f6892c35a090439a7071ddadf46">&#9670;&#160;</a></span>os_thread_populate_stack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t * os_thread_populate_stack </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stack_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>stack_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">entrypoint_t *&#160;</td>
          <td class="paramname"><em>entrypoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate stack of new thread so it can be executed. </p>
<p>Populates stack of new thread so that it can be executed with no other actions required. Returns the address where SP shall point to. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stack_id</td><td>ID of stack to be populated </td></tr>
    <tr><td class="paramname">stack_size</td><td>size of stack in 32-bit quantities </td></tr>
    <tr><td class="paramname">entrypoint</td><td>address of thread entrypoint function </td></tr>
    <tr><td class="paramname">data</td><td>address of data passed to the thread as its 1st argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Address to which the SP shall be set. </dd></dl>

</div>
</div>
<a id="gad4128fe30c4eef560ae2dc025e89abf2" name="gad4128fe30c4eef560ae2dc025e89abf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4128fe30c4eef560ae2dc025e89abf2">&#9670;&#160;</a></span>static_init_process_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned static_init_process_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides count of statically initialized processes. </p>
<dl class="section return"><dt>Returns</dt><dd>amount of processes that have to be statically initialized </dd></dl>

</div>
</div>
<a id="ga40ff64621b791a06874bb7ca27a9164e" name="ga40ff64621b791a06874bb7ca27a9164e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga40ff64621b791a06874bb7ca27a9164e">&#9670;&#160;</a></span>static_init_process_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const struct <a class="el" href="structOS__process__definition__t.html">OS_process_definition_t</a> * static_init_process_table </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides address of statically intialized process table. </p>
<dl class="section return"><dt>Returns</dt><dd>address of table containins details of statically initialized processes </dd></dl>

</div>
</div>
<a id="gaa1e4c4f6735a5acd050873acdb00cdbf" name="gaa1e4c4f6735a5acd050873acdb00cdbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1e4c4f6735a5acd050873acdb00cdbf">&#9670;&#160;</a></span>static_init_thread_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned static_init_thread_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides count of statically initialized threads. </p>
<dl class="section return"><dt>Returns</dt><dd>amount of threads that have to be statically initialized </dd></dl>

</div>
</div>
<a id="gab06a63362ae820b797a3bf0b1c6386a0" name="gab06a63362ae820b797a3bf0b1c6386a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab06a63362ae820b797a3bf0b1c6386a0">&#9670;&#160;</a></span>static_init_thread_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const struct <a class="el" href="structOS__thread__create__t.html">OS_thread_create_t</a> * static_init_thread_table </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides address of statically initialized thread table. </p>
<dl class="section return"><dt>Returns</dt><dd>address of table containing details of statically initialized threads </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.7-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</div>
</body>
</html>
