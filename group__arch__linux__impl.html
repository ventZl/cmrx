<!-- HTML header for doxygen 1.9.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>C Microkernel Realtime eXecutive: Implementation details</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="all">
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">C Microkernel Realtime eXecutive
   </div>
   <div id="projectbrief">Realtime Operating System for Cortex-M based microcontrollers</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__arch__linux__impl.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">Implementation details<div class="ingroups"><a class="el" href="group__os.html">Kernel documentation</a> &raquo; <a class="el" href="group__arch.html">Architecture support</a> &raquo; <a class="el" href="group__arch__linux.html">Linux port</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>This group contains platform-specific routines that implement internal behavior of this port.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structthread__startup__t.html">thread_startup_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal thread startup data structure.  <a href="structthread__startup__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga883fd2b09ba21d087075a822d98158a4" id="r_ga883fd2b09ba21d087075a822d98158a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__arch__linux__impl.html#ga883fd2b09ba21d087075a822d98158a4">trigger_pendsv_if_needed</a> ()</td></tr>
<tr class="memdesc:ga883fd2b09ba21d087075a822d98158a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trigger thread switch if requested.  <br /></td></tr>
<tr class="separator:ga883fd2b09ba21d087075a822d98158a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81c247bf7d6d7c6f4badbbf40607c2d5" id="r_ga81c247bf7d6d7c6f4badbbf40607c2d5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__arch__linux__impl.html#ga81c247bf7d6d7c6f4badbbf40607c2d5">system_call_entrypoint</a> (unsigned long arg0, unsigned long arg1, unsigned long arg2, unsigned long arg3, unsigned long arg4, unsigned long arg5, unsigned char syscall_id)</td></tr>
<tr class="memdesc:ga81c247bf7d6d7c6f4badbbf40607c2d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entrypoint into system call machinery.  <br /></td></tr>
<tr class="separator:ga81c247bf7d6d7c6f4badbbf40607c2d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga088ad6d4933a22b4b65cea8982274b25" id="r_ga088ad6d4933a22b4b65cea8982274b25"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__arch__linux__impl.html#ga088ad6d4933a22b4b65cea8982274b25">thread_switch_handler</a> (int signo)</td></tr>
<tr class="memdesc:ga088ad6d4933a22b4b65cea8982274b25"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function handles the heavy lifting of thread switching.  <br /></td></tr>
<tr class="separator:ga088ad6d4933a22b4b65cea8982274b25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b8366627990f55eac34dfb7fe36a099" id="r_ga0b8366627990f55eac34dfb7fe36a099"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__arch__linux__impl.html#ga0b8366627990f55eac34dfb7fe36a099">kernel_service_handler</a> (int signo)</td></tr>
<tr class="memdesc:ga0b8366627990f55eac34dfb7fe36a099"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handler for kernel service call.  <br /></td></tr>
<tr class="separator:ga0b8366627990f55eac34dfb7fe36a099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7aa1e323243992dc3c2b91db8b0b771a" id="r_ga7aa1e323243992dc3c2b91db8b0b771a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__arch__linux__impl.html#ga7aa1e323243992dc3c2b91db8b0b771a">thread_startup_handler</a> (void *arg)</td></tr>
<tr class="memdesc:ga7aa1e323243992dc3c2b91db8b0b771a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Routine to jump-start guest thread host.  <br /></td></tr>
<tr class="separator:ga7aa1e323243992dc3c2b91db8b0b771a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga469c6b96a6ac6b12bc7eb93514e37c67" id="r_ga469c6b96a6ac6b12bc7eb93514e37c67"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__arch__linux__impl.html#ga469c6b96a6ac6b12bc7eb93514e37c67">cmrx_posix_register_syscalls</a> (struct <a class="el" href="structSyscall__Entry__t.html">Syscall_Entry_t</a> *added_syscalls)</td></tr>
<tr class="memdesc:ga469c6b96a6ac6b12bc7eb93514e37c67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register syscall with kernel.  <br /></td></tr>
<tr class="separator:ga469c6b96a6ac6b12bc7eb93514e37c67"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gaf755bea0ee650e391e9ae2775b7131f4" id="r_gaf755bea0ee650e391e9ae2775b7131f4"><td class="memItemLeft" align="right" valign="top">static volatile bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__arch__linux__impl.html#gaf755bea0ee650e391e9ae2775b7131f4">kernel_execute_thread_switch</a> = false</td></tr>
<tr class="memdesc:gaf755bea0ee650e391e9ae2775b7131f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shall thread switch be performed? While kernel timer is called periodically, it doesn't perform thread switch inside the handler.  <br /></td></tr>
<tr class="separator:gaf755bea0ee650e391e9ae2775b7131f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2270ed6c370218d82eed7be5845f1718" id="r_ga2270ed6c370218d82eed7be5845f1718"><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structSyscall__Entry__t.html">Syscall_Entry_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__arch__linux__impl.html#ga2270ed6c370218d82eed7be5845f1718">syscalls</a> [256] = { 0 }</td></tr>
<tr class="memdesc:ga2270ed6c370218d82eed7be5845f1718"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of registered syscalls.  <br /></td></tr>
<tr class="separator:ga2270ed6c370218d82eed7be5845f1718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18ed810d4a83aa447a3c4b2a1842de62" id="r_ga18ed810d4a83aa447a3c4b2a1842de62"><td class="memItemLeft" align="right" valign="top">static unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__arch__linux__impl.html#ga18ed810d4a83aa447a3c4b2a1842de62">syscalls_count</a> = 0</td></tr>
<tr class="memdesc:ga18ed810d4a83aa447a3c4b2a1842de62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counter for known syscalls.  <br /></td></tr>
<tr class="separator:ga18ed810d4a83aa447a3c4b2a1842de62"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>This group contains platform-specific routines that implement internal behavior of this port. </p>
<p>Each CMRX thread is backed by one Linux thread. CMRX kernel is using signals and blocking syscalls to enforce preemption on threads.</p>
<p>Internally the architecture of the port is similar to the ARM Cortex-M one. Kernel is using timers "interrupt" and "thread switch interrupt". These "interrupts" are serviced by kernel thread synchronously, so they never preempt each other. This makes sure that threads are never switched while inside syscall. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaebe45632e3c7e1241ab83d9738cf37fa" name="gaebe45632e3c7e1241ab83d9738cf37fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaebe45632e3c7e1241ab83d9738cf37fa">&#9670;&#160;</a></span>cmrx_posix_register_application()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cmrx_posix_register_application </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structOS__process__definition__t.html">OS_process_definition_t</a> *&#160;</td>
          <td class="paramname"><em>process</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal routine to register application with kernel. </p>
<p>This routine is used by the static creation mechanism to register application with kernel. It will be called before the main() is executed. It puts application definition into list of known application definitions for the kernel to create this process upon kernel startup. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">process</td><td>process definition structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is kernel-private and specific to Linux port </dd></dl>

</div>
</div>
<a id="ga469c6b96a6ac6b12bc7eb93514e37c67" name="ga469c6b96a6ac6b12bc7eb93514e37c67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga469c6b96a6ac6b12bc7eb93514e37c67">&#9670;&#160;</a></span>cmrx_posix_register_syscalls()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cmrx_posix_register_syscalls </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structSyscall__Entry__t.html">Syscall_Entry_t</a> *&#160;</td>
          <td class="paramname"><em>added_syscalls</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register syscall with kernel. </p>
<p>The call to this function is arranged by each block where syscalls are defined. It registers all syscalls provided in syscall registration request.</p>
<p>This function is called during constructor phase, before main was executed. </p>

</div>
</div>
<a id="gaa7a0ab90572f51e2abea738e291fc0a0" name="gaa7a0ab90572f51e2abea738e291fc0a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa7a0ab90572f51e2abea738e291fc0a0">&#9670;&#160;</a></span>cmrx_posix_register_thread()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cmrx_posix_register_thread </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structOS__thread__create__t.html">OS_thread_create_t</a> *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal routine to register thread with kernel. </p>
<p>This routine is used by the thread autostart mechanism to register thread with kernel. It will be called before the main() is executed. It puts thread definition into list of known thread definitions for the kernel to create this thread upon kernel startup. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">process</td><td>thread definition structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is kernel-private and specific to Linux port </dd></dl>

</div>
</div>
<a id="ga0b8366627990f55eac34dfb7fe36a099" name="ga0b8366627990f55eac34dfb7fe36a099"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b8366627990f55eac34dfb7fe36a099">&#9670;&#160;</a></span>kernel_service_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void kernel_service_handler </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>signo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handler for kernel service call. </p>
<p>This handler handles kernel syscall execution. The fact that kernel syscalls are called via this handler makes sure that:</p><ol type="1">
<li>kernel syscall is never interrupted via timer</li>
<li>only one thread is ever inside syscall </li>
</ol>

</div>
</div>
<a id="ga81c247bf7d6d7c6f4badbbf40607c2d5" name="ga81c247bf7d6d7c6f4badbbf40607c2d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81c247bf7d6d7c6f4badbbf40607c2d5">&#9670;&#160;</a></span>system_call_entrypoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int system_call_entrypoint </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>arg0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>arg2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>arg3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>arg4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>arg5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>syscall_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Entrypoint into system call machinery. </p>
<p>This function will fill thread-private buffer for system call data and will dispatch the system call handler to be called. </p>

</div>
</div>
<a id="ga7aa1e323243992dc3c2b91db8b0b771a" name="ga7aa1e323243992dc3c2b91db8b0b771a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7aa1e323243992dc3c2b91db8b0b771a">&#9670;&#160;</a></span>thread_startup_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int thread_startup_handler </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Routine to jump-start guest thread host. </p>
<p>This routine will configure the Linux thread to act as a host for CMRX thread. We don't want ' This is a Linux thread that hosts guest thread. We don't want these threads to process timer signals. These are basically ever only sensitive to SIGUSR1 which is used to force preemption. </p>
<p>Allow reception of SIGALRM, SIGUSR1 (PendSV) and SIGURG (SVCHandler) signals in CMRX thread hosting threads</p>

</div>
</div>
<a id="ga088ad6d4933a22b4b65cea8982274b25" name="ga088ad6d4933a22b4b65cea8982274b25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga088ad6d4933a22b4b65cea8982274b25">&#9670;&#160;</a></span>thread_switch_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void thread_switch_handler </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>signo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function handles the heavy lifting of thread switching. </p>
<p>Another thread is woken-up by unblocking it, then this thread is suspended. </p>

</div>
</div>
<a id="ga883fd2b09ba21d087075a822d98158a4" name="ga883fd2b09ba21d087075a822d98158a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga883fd2b09ba21d087075a822d98158a4">&#9670;&#160;</a></span>trigger_pendsv_if_needed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void trigger_pendsv_if_needed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trigger thread switch if requested. </p>
<p>Initiate thread switch sequence if it was requested.</p>
<p>Triggers thread switch interrupt if requested and clears the flag. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread_stopped</td><td>true if thread is already stopped (e.g. due to entering system call) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This should always be ran in CMRX thread context </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="gaf755bea0ee650e391e9ae2775b7131f4" name="gaf755bea0ee650e391e9ae2775b7131f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf755bea0ee650e391e9ae2775b7131f4">&#9670;&#160;</a></span>kernel_execute_thread_switch</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">volatile bool kernel_execute_thread_switch = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shall thread switch be performed? While kernel timer is called periodically, it doesn't perform thread switch inside the handler. </p>
<p>Rather it schedules thread switch interrupt which is then executed synchronously by the "kernel" thread. This flag holds information if this thread switch should be requested or not. Due to the semantics of CMRX it is possible that this flag will be activated and then deactivated before thread switch happens (e.g. because interrupt caused thread wakeup before thread managed to be scheduled out of CPU). </p>

</div>
</div>
<a id="ga8bf3aeec7102f453eb9e9671d13beefd" name="ga8bf3aeec7102f453eb9e9671d13beefd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8bf3aeec7102f453eb9e9671d13beefd">&#9670;&#160;</a></span>os_process_definitions</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structOS__process__definition__t.html">OS_process_definition_t</a> os_process_definitions[<a class="el" href="group__os__config.html#gacac8dbdebb899857ee307d8c8d917392">OS_PROCESSES</a>]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Structure that holds information on process definitions. </p>

</div>
</div>
<a id="ga72adc2af4b9efc69ab8b0439d311bc1e" name="ga72adc2af4b9efc69ab8b0439d311bc1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga72adc2af4b9efc69ab8b0439d311bc1e">&#9670;&#160;</a></span>os_thread_definitions</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structOS__thread__create__t.html">OS_thread_create_t</a> os_thread_definitions[<a class="el" href="group__os__config.html#ga1383e9a762dc5563440cf1623542667d">OS_THREADS</a>]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Structure that holds information on autostarted threads. </p>

</div>
</div>
<a id="gad607d3bf724355c6474cb14a5ad9663d" name="gad607d3bf724355c6474cb14a5ad9663d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad607d3bf724355c6474cb14a5ad9663d">&#9670;&#160;</a></span>process_count</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned process_count = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Counter for known process definitions. </p>

</div>
</div>
<a id="ga2270ed6c370218d82eed7be5845f1718" name="ga2270ed6c370218d82eed7be5845f1718"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2270ed6c370218d82eed7be5845f1718">&#9670;&#160;</a></span>syscalls</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structSyscall__Entry__t.html">Syscall_Entry_t</a> syscalls[256] = { 0 }</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>List of registered syscalls. </p>
<p>This list contains syscall definitions that were registered with kernel. The registration happens automatically if REGISTER_SYSCALLS macro was used. </p>

</div>
</div>
<a id="ga18ed810d4a83aa447a3c4b2a1842de62" name="ga18ed810d4a83aa447a3c4b2a1842de62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga18ed810d4a83aa447a3c4b2a1842de62">&#9670;&#160;</a></span>syscalls_count</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned syscalls_count = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Counter for known syscalls. </p>
<p>This counter holds amount of syscalls known to the kernel. </p><dl class="section note"><dt>Note</dt><dd>This does not relate to syscall number, where highest syscall number may be higher than this count. It should never be lower though. </dd></dl>

</div>
</div>
<a id="ga66dd127a54d740417fbc5d273617cd5a" name="ga66dd127a54d740417fbc5d273617cd5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga66dd127a54d740417fbc5d273617cd5a">&#9670;&#160;</a></span>thread_count</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned thread_count = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Counter for autostarted threads. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.7-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</div>
</body>
</html>
